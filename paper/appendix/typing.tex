In this section, we present the full typing rules of \TLLC{}. We organize the
typing rules into logical level, program level and process level.

\subsection{Logical Level}
The typing judgment for the logical level has the form $\Gamma \vdash m : A$.
This judgment states that under the \emph{logical context} $\Gamma$, term $m$
has type $A$. The logical level is completely \emph{structural}.

\paragraph{\textbf{Logical Context}}
The logical context $\Gamma$ is a sequence of variable bindings of the form 
$x_0 : A_0, x_1 : A_1, \dots, x_n : A_n$. Each variable $x_i$ is bound to a type $A_i$.
Variables in the logical context are unrestricted and can be used arbitrarily many
times. The empty context is denoted by $\epsilon$. To ensure the validity of types
in the logical context, we define the context validity judgment $\Gamma \vdash $.
\begin{mathpar}
  \inferrule[Ctx-Empty]
  { }
  { \epsilon \vdash }

  \inferrule[Ctx-Var]
  { \Gamma \vdash \quad \Gamma \vdash A : s \\
    x \notin \Gamma }
  { \Gamma, x : A \vdash }
\end{mathpar}
Note that the context validity judgment is \emph{mutually inductively} defined with the typing judgment. 

\paragraph{\textbf{Core Typing}}
The core typing rules is responsible for the functional fragment of \TLLC{}.
The convertibility relation $A \simeq B$ is used in the conversion rule to
allow type equivalence up to $\beta$-reduction. We will present the definition
of the convertibility relation in \Cref{appendix:logical-semantics}. 
\begin{mathpar}\footnotesize
  \inferrule[Sort]
  { \Gamma \vdash }
  { \Gamma \vdash s : \Un }

  \inferrule[Var]
  { \Gamma, x : A \vdash }
  { \Gamma, x : A \vdash x : A }

  \inferrule[Conversion]
  { \Gamma \vdash B : s \\
    \Gamma \vdash m : A \\
    A \simeq B }
  { \Gamma \vdash m : B }

  \inferrule[Explicit-Fun]
  { \Gamma \vdash A : s \\
    \Gamma, x : A \vdash B : r }
  { \Gamma \vdash \PiR{t}{x : A}{B} : t }

  \inferrule[Implicit-Fun]
  { \Gamma \vdash A : s \\
    \Gamma, x : A \vdash B : r }
  { \Gamma \vdash \PiI{t}{x : A}{B} : t }

  \inferrule[Explicit-Lam]
  { \Gamma, x : A \vdash m : B }
  { \Gamma \vdash \lamR{t}{x : A}{m} : \PiR{t}{x : A}{B} }

  \inferrule[Implicit-Lam]
  { \Gamma, x : A \vdash m : B }
  { \Gamma \vdash \lamI{t}{x : A}{m} : \PiI{t}{x : A}{B} }

  \inferrule[Explicit-App]
  { \Gamma \vdash m : \PiR{t}{x : A}{B} \\
    \Gamma \vdash n : A }
  { \Gamma \vdash \appR{m}{n} : B[n/x] }

  \inferrule[Implicit-App]
  { \Gamma \vdash m : \PiI{t}{x : A}{B} \\
    \Gamma \vdash n : A }
  { \Gamma \vdash \appI{m}{n} : B[n/x] }

  \inferrule[Explicit-Sum]
  { s \sqsubseteq t \\ r \sqsubseteq t \\
    \Gamma \vdash A : s \\
    \Gamma, x : A \vdash B : r }
  { \Gamma \vdash \SigR{t}{x : A}{B} : t }

  \inferrule[Implicit-Sum]
  { r \sqsubseteq t \\
    \Gamma \vdash A : s \\
    \Gamma, x : A \vdash B : r }
  { \Gamma \vdash \SigI{t}{x : A}{B} : t }

  \inferrule[Explicit-Pair]
  { \Gamma \vdash \SigR{t}{x : A}{B} : t \\
    \Gamma \vdash m : A \\
    \Gamma \vdash n : B[m/x] }
  { \Gamma \vdash \pairR{m}{n}{t} : \SigR{t}{x : A}{B} }

  \inferrule[Implicit-Pair]
  { \Gamma \vdash \SigI{t}{x : A}{B} : t \\
    \Gamma \vdash m : A \\
    \Gamma \vdash n : B[m/x] }
  { \Gamma \vdash \pairI{m}{n}{t} : \SigI{t}{x : A}{B} }

  \inferrule[Explicit-SumElim]
  { \Gamma, z : \SigR{t}{x : A}{B} \vdash C : s \\
    \Gamma \vdash m : \SigR{t}{x : A}{B} \\
    \Gamma, x : A, y : B \vdash n : C[\pairR{x}{y}{t}/z] }
  { \Gamma \vdash \SigElim{[z]C}{m}{[x,y]n} : C[m/z] }

  \inferrule[Implicit-SumElim]
  { \Gamma, z : \SigI{t}{x : A}{B} \vdash C : s \\
    \Gamma \vdash m : \SigI{t}{x : A}{B} \\
    \Gamma, x : A, y : B \vdash n : C[\pairI{x}{y}{t}/z] }
  { \Gamma \vdash \SigElim{[z]C}{m}{[x,y]n} : C[m/z] }
\end{mathpar}
\clearpage

\paragraph{\textbf{Data Typing}}
The data typing rules govern the typing of base types such as the unit type and
the boolean type. The rules are presented below.
\begin{mathpar}\small
  \inferrule[Unit]
  { \Gamma \vdash }
  { \Gamma \vdash \unit : \Un }

  \inferrule[UnitVal]
  { \Gamma \vdash }
  { \Gamma \vdash \ii : \unit }

  \inferrule[Bool]
  { \Gamma \vdash }
  { \Gamma \vdash \Bool : \Un }

  \inferrule[True]
  { \Gamma \vdash }
  { \Gamma \vdash \bTrue : \Bool }

  \inferrule[False]
  { \Gamma \vdash }
  { \Gamma \vdash \bFalse : \Bool }\\

  \inferrule[BoolElim]
  { \Gamma, z : \Bool \vdash A : s \\
    \Gamma \vdash m : \Bool \\
    \Gamma \vdash n_1 : A[\bTrue/z] \\
    \Gamma \vdash n_2 : A[\bFalse/z] }
  { \Gamma \vdash \boolElim{[z]A}{m}{n_1}{n_2} : A[m/z] }\\
\end{mathpar}

\paragraph{\textbf{Monadic Typing}}
The monadic typing rules govern the composition of monadic computations.
The standard rules for monadic return and bind are presented below.
\begin{mathpar}\small
  \inferrule[$\C$Type]
  { \Gamma \vdash A : s }
  { \Gamma \vdash \CM{A} : \Ln }

  \inferrule[Return]
  { \Gamma \vdash m : A }
  { \Gamma \vdash \return{m} : \CM{A} }

  \inferrule[Bind]
  { \Gamma \vdash B : s \\
    \Gamma \vdash m : \CM{A} \\
    \Gamma, x : A \vdash n : \CM{B} }
  { \Gamma \vdash \letin{x}{m}{n} : \CM{B} }\\
\end{mathpar}

\paragraph{\textbf{Session Typing}}
The session typing rules govern the typing of protocol, channels and concurrency
primitives. The rules are presented below.
\begin{mathpar}\footnotesize
  \inferrule[Proto]
  { \Gamma \vdash }
  { \Gamma \vdash \Proto : \Un }

  \inferrule[End]
  { \Gamma \vdash }
  { \Gamma \vdash \End : \Proto }

  \inferrule[Explicit-Action]
  { \Gamma, x : A \vdash B : \Proto }
  { \Gamma \vdash \ActR{\rho}{x : A}{B} : \Proto }

  \inferrule[Implicit-Action]
  { \Gamma, x : A \vdash B : \Proto }
  { \Gamma \vdash \ActI{\rho}{x : A}{B} : \Proto }

  \inferrule[RecProto]
  { \Gamma, x : A \vdash m : A \\
    A~\arity{\Proto} \\ 
    m~\guard{x} }
  { \Gamma \vdash \fix{x : A}{m} : A }

  \inferrule[ChType]
  { \Gamma \vdash A : \Proto }
  { \Gamma \vdash \CH{A} : \Ln }

  \inferrule[HcType]
  { \Gamma \vdash A : \Proto }
  { \Gamma \vdash \HC{A} : \Ln }

  \inferrule[Channel-CH]
  { \Gamma \vdash \\
    \epsilon \vdash A : \Proto }
  { \Gamma \vdash c : \CH{A} }

  \inferrule[Channel-HC]
  { \Gamma \vdash \\
    \epsilon \vdash A : \Proto }
  { \Gamma \vdash c : \HC{A} }

  \inferrule[Explicit-Send-CH]
  { \Gamma \vdash m : \CH{\ActR{!}{x : A}{B}} }
  { \Gamma \vdash \sendR{m} : \PiR{\Ln}{x : A}{\CM{\CH{B}}} }

  \inferrule[Explicit-Send-HC]
  { \Gamma \vdash m : \HC{\ActR{?}{x : A}{B}} }
  { \Gamma \vdash \sendR{m} : \PiR{\Ln}{x : A}{\CM{\HC{B}}} }

  \inferrule[Implicit-Send-CH]
  { \Gamma \vdash m : \CH{\ActI{!}{x : A}{B}} }
  { \Gamma \vdash \sendI{m} : \PiI{\Ln}{x : A}{\CM{\CH{B}}} }

  \inferrule[Implicit-Send-HC]
  { \Gamma \vdash m : \HC{\ActI{?}{x : A}{B}} }
  { \Gamma \vdash \sendI{m} : \PiI{\Ln}{x : A}{\CM{\HC{B}}} }

  \inferrule[Explicit-Recv-CH]
  { \Gamma \vdash m : \CH{\ActR{?}{x : A}{B}} }
  { \Gamma \vdash \recvR{m} : \CM{\SigR{\Ln}{x : A}{\CH{B}}} }

  \inferrule[Explicit-Recv-HC]
  { \Gamma \vdash m : \HC{\ActR{!}{x : A}{B}} }
  { \Gamma \vdash \recvR{m} : \CM{\SigR{\Ln}{x : A}{\HC{B}}} }

  \inferrule[Implicit-Recv-CH]
  { \Gamma \vdash m : \CH{\ActI{?}{x : A}{B}} }
  { \Gamma \vdash \recvI{m} : \CM{\SigI{\Ln}{x : A}{\CH{B}}} }

  \inferrule[Implicit-Recv-HC]
  { \Gamma \vdash m : \HC{\ActI{!}{x : A}{B}} }
  { \Gamma \vdash \recvI{m} : \CM{\SigI{\Ln}{x : A}{\HC{B}}} }

  \inferrule[Fork]
  { \Gamma, x : \CH{A} \vdash m : \CM{\unit} }
  { \Gamma \vdash \fork{x : \CH{A}}{m} : \CM{\HC{A}} }

  \inferrule[Close]
  { \Gamma \vdash m : \CH{\End} }
  { \Gamma \vdash \close{m} : \CM{\unit} }

  \inferrule[Wait]
  { \Gamma \vdash m : \HC{\End} }
  { \Gamma \vdash \wait{m} : \CM{\unit} }
\end{mathpar}
\clearpage

\subsection{Program Level}\label{appendix:program-typing}
The typing judgment for the program level has the form $\Theta ; \Gamma ; \Delta \vdash m : A$.
This judgment states that under the channel context $\Theta$, logical context $\Gamma$ and the
\emph{program context} $\Delta$, term $m$ has type $A$. The program level is \emph{substructural}
as the usage of variables in the program context is tracked.

\paragraph{\textbf{Program Context}}
The program context $\Delta$ is a sequence of variable bindings of the form
$x_0 :_{s_0} A_0, x_1 :_{s_1} A_1, \dots, x_n :_{s_n} A_n$. 
Each variable $x_i$ is bound to a type $A_i$ with a sort annotation $s_i$.
The variables in the program context are allowed to appear in computationally
relevant positions inside $m$. To ensure that all types appear in the program
context are well-formed, we define the program context validity judgment
$\Gamma ; \Delta \vdash $. The rules for this judgment are presented below.
\begin{mathpar}\small
  \inferrule[Ctx-Empty]
  { }
  { \epsilon ; \epsilon \vdash }

  \inferrule[Ctx-Implicit-Var]
  { \Gamma ; \Delta \vdash \\
    \Gamma \vdash A : s \\
    x \notin \Gamma }
  { \Gamma, x : A ; \Delta \vdash }

  \inferrule[Ctx-Explicit-Var]
  { \Gamma ; \Delta \vdash \\
    \Gamma \vdash A : s \\
    x \notin \Gamma }
  { \Gamma, x : A ; \Delta, x \ty{s} A \vdash }
\end{mathpar}
From these rules we can see that $\text{dom}(\Delta)$ is a subset of
$\text{dom}(\Gamma)$. Additionally, the sort annotation $s$ in each program
context binding $x \ty{s} A$ is the sort of the associated $A$ type.

\paragraph{\textbf{Core Typing}}
The core typing rules is responsible for the functional fragment of \TLLC{}.
\begin{mathpar}\footnotesize
  \inferrule[Var]
  { \epsilon ; \Gamma, x : A ; \Delta, x \ty{s} A \vdash \\
    \Delta \triangleright \Un }
  { \epsilon ; \Gamma, x : A ; \Delta, x \ty{s} A \vdash x : A }

  \inferrule[Conversion]
  { \Gamma \vdash B : s \\
    \Theta ; \Gamma ; \Delta \vdash m : A \\
    A \simeq B }
  { \Theta ; \Gamma ; \Delta \vdash m : B }

  \inferrule[Explicit-Lam]
  { \Theta ; \Gamma, x : A; \Delta, x \ty{s} A \vdash m : B \\
    \Theta \triangleright t \\
    \Delta \triangleright t }
  { \Theta ; \Gamma ; \Delta \vdash \lamR{t}{x : A}{m} : \PiR{t}{x : A}{B} }

  \inferrule[Implicit-Lam]
  { \Theta ; \Gamma, x : A; \Delta \vdash m : B \\
    \Theta \triangleright t \\
    \Delta \triangleright t }
  { \Theta ; \Gamma ; \Delta \vdash \lamI{t}{x : A}{m} : \PiI{t}{x : A}{B} }

  \inferrule[Explicit-App]
  { \Theta_1 ; \Gamma ; \Delta_1 \vdash m : \PiR{t}{x : A}{B} \\
    \Theta_2 ; \Gamma ; \Delta_2 \vdash n : A }
  { \Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash \appR{m}{n} : B[n/x] }

  \inferrule[Implicit-App]
  { \Theta ; \Gamma ; \Delta \vdash m : \PiI{t}{x : A}{B} \\
    \Gamma \vdash n : A }
  { \Theta ; \Gamma ; \Delta \vdash \appI{m}{n} : B[n/x] }

  \inferrule[Explicit-Pair]
  { \Gamma \vdash \SigR{t}{x : A}{B} : t \\\\
    \Theta_1 ; \Gamma ; \Delta_1 \vdash m : A \\
    \Theta_2 ; \Gamma ; \Delta_2 \vdash n : B[m/x] }
  { \Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash \pairR{m}{n}{t} : \SigR{t}{x : A}{B} }

  \inferrule[Implicit-Pair]
  { \Gamma \vdash \SigI{t}{x : A}{B} : t \\\\
    \Gamma \vdash m : A \\
    \Theta ; \Gamma ; \Delta \vdash n : B[m/x] }
  { \Theta ; \Gamma ; \Delta \vdash \pairI{m}{n}{t} : \SigI{t}{x : A}{B} }

  \inferrule[Explicit-SumElim]
  { \Gamma, z : \SigR{t}{x : A}{B} \vdash C : s \\
    \Theta_1 ; \Gamma ; \Delta_1 \vdash m : \SigR{t}{x : A}{B} \\\\
    \Theta_2 ; \Gamma, x : A, y : B; \Delta_2, x \ty{r1} A, y \ty{r2} B \vdash n : C[\pairR{x}{y}{t}/z] }
  { \Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash \SigElim{[z]C}{m}{[x,y]n} : C[m/z] }

  \inferrule[Implicit-SumElim]
  { \Gamma, z : \SigI{t}{x : A}{B} \vdash C : s \\
    \Theta_1 ; \Gamma ; \Delta_1 \vdash m : \SigI{t}{x : A}{B} \\\\
    \Theta_2 ; \Gamma, x : A, y : B; \Delta_2, y \ty{r} B \vdash n : C[\pairI{x}{y}{t}/z] }
  { \Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash \SigElim{[z]C}{m}{[x,y]n} : C[m/z] }\\
\end{mathpar}

\paragraph{\textbf{Data Typing}}
The data typing rules govern the typing of base types such as the unit type and
the boolean type. The rules are presented below.
\begin{mathpar}\footnotesize
  \inferrule[UnitVal]
  { \Gamma ; \Delta \vdash \\ \Delta \triangleright \Un }
  { \epsilon ; \Gamma ; \Delta \vdash \ii : \unit }

  \inferrule[True]
  { \Gamma ; \Delta \vdash \\ \Delta \triangleright \Un }
  { \epsilon ; \Gamma ; \Delta \vdash \bTrue : \Bool }

  \inferrule[False]
  { \Gamma ; \Delta \vdash \\ \Delta \triangleright \Un }
  { \epsilon ; \Gamma ; \Delta \vdash \bFalse : \Bool }

  \inferrule[BoolElim]
  { \Gamma, z : \Bool \vdash A : s \\
    \Theta_1 ; \Gamma ; \Delta_1 \vdash m : \Bool \\
    \Theta_2 ; \Gamma ; \Delta_2 \vdash n_1 : A[\bTrue/z] \\
    \Theta_2 ; \Gamma ; \Delta_2 \vdash n_2 : A[\bFalse/z] }
  { \Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash 
    \boolElim{[z]A}{m}{n_1}{n_2} : A[m/z] }
\end{mathpar}

\paragraph{\textbf{Monadic Typing}}
The monadic typing rules govern the composition of monadic computations.
The standard rules for monadic return and bind are presented below.
\begin{mathpar}\small
  \inferrule[Return]
  { \Theta ; \Gamma ; \Delta \vdash m : A }
  { \Theta ; \Gamma ; \Delta \vdash \return{m} : \CM{A} }

  \inferrule[Bind]
  { \Gamma \vdash B : s \\
    \Theta_1 ; \Gamma ; \Delta_1 \vdash m : \CM{A} \\
    \Theta_2 ; \Gamma, x : A ; \Delta_2, x \ty{r} A \vdash n : \CM{B} }
  { \Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash \letin{x}{m}{n} : \CM{B} }
\end{mathpar}

\paragraph{\textbf{Session Typing}}
The session typing rules govern the typing of channels and concurrency
primitives. The rules are presented below.
\begin{mathpar}\footnotesize
  \inferrule[Channel-CH]
  { \Gamma ; \Delta \vdash \\
    \epsilon \vdash A : \Proto \\
    \Delta \triangleright \Un }
  { c \tL \CH{A} ; \Gamma ; \Delta \vdash c : \CH{A} }

  \inferrule[Channel-HC]
  { \Gamma ; \Delta \vdash \\
    \epsilon \vdash A : \Proto \\
    \Delta \triangleright \Un }
  { c \tL \HC{A} ; \Gamma ; \Delta \vdash c : \HC{A} }

  \inferrule[Explicit-Send-CH]
  { \Theta ; \Gamma ; \Delta \vdash m : \CH{\ActR{!}{x : A}{B}} }
  { \Theta ; \Gamma ; \Delta \vdash \sendR{m} : \PiR{\Ln}{x : A}{\CM{\CH{B}}} }

  \inferrule[Explicit-Send-HC]
  { \Theta ; \Gamma ; \Delta \vdash m : \HC{\ActR{?}{x : A}{B}} }
  { \Theta ; \Gamma ; \Delta \vdash \sendR{m} : \PiR{\Ln}{x : A}{\CM{\HC{B}}} }

  \inferrule[Implicit-Send-CH]
  { \Theta ; \Gamma ; \Delta \vdash m : \CH{\ActI{!}{x : A}{B}} }
  { \Theta ; \Gamma ; \Delta \vdash \sendI{m} : \PiI{\Ln}{x : A}{\CM{\CH{B}}} }

  \inferrule[Implicit-Send-HC]
  { \Theta ; \Gamma ; \Delta \vdash m : \HC{\ActI{?}{x : A}{B}} }
  { \Theta ; \Gamma ; \Delta \vdash \sendI{m} : \PiI{\Ln}{x : A}{\CM{\HC{B}}} }

  \inferrule[Explicit-Recv-CH]
  { \Theta ; \Gamma ; \Delta \vdash m : \CH{\ActR{?}{x : A}{B}} }
  { \Theta ; \Gamma ; \Delta \vdash \recvR{m} : \CM{\SigR{\Ln}{x : A}{\CH{B}}} }

  \inferrule[Explicit-Recv-HC]
  { \Theta ; \Gamma ; \Delta \vdash m : \HC{\ActR{!}{x : A}{B}} }
  { \Theta ; \Gamma ; \Delta \vdash \recvR{m} : \CM{\SigR{\Ln}{x : A}{\HC{B}}} }

  \inferrule[Implicit-Recv-CH]
  { \Theta ; \Gamma ; \Delta \vdash m : \CH{\ActI{?}{x : A}{B}} }
  { \Theta ; \Gamma ; \Delta \vdash \recvI{m} : \CM{\SigI{\Ln}{x : A}{\CH{B}}} }

  \inferrule[Implicit-Recv-HC]
  { \Theta ; \Gamma ; \Delta \vdash m : \HC{\ActI{!}{x : A}{B}} }
  { \Theta ; \Gamma ; \Delta \vdash \recvI{m} : \CM{\SigI{\Ln}{x : A}{\HC{B}}} }

  \inferrule[Fork]
  { \Theta ; \Gamma, x : \CH{A} ; \Delta, x \tL \CH{A} \vdash m : \CM{\unit} }
  { \Theta ; \Gamma ; \Delta \vdash \fork{x : \CH{A}}{m} : \CM{\HC{A}} }

  \inferrule[Close]
  { \Theta ; \Gamma ; \Delta \vdash m : \CH{\End} }
  { \Theta ; \Gamma ; \Delta \vdash \close{m} : \CM{\unit} }

  \inferrule[Wait]
  { \Theta ; \Gamma ; \Delta \vdash m : \HC{\End} }
  { \Theta ; \Gamma ; \Delta \vdash \wait{m} : \CM{\unit} }
\end{mathpar}

\subsection{Process Level}
The typing judgment for the process level has the form $\Theta \Vdash P$. 
This judgment states that under the channel context $\Theta$, process $P$ is well-typed.
Unlike the logical and program levels which can type term that contain free variables, 
the process level only types processes whose terms are closed. Hence, there are no logical
or program contexts in the process typing judgment.
\begin{mathpar}\small
  \inferrule[Expr]
  { \Theta ; \epsilon ; \epsilon \vdash m : \CM{\unit} }
  { \Theta \Vdash \proc{m} }

  \inferrule[Par]
  { \Theta_1 \vdash P \\ \Theta_2 \vdash Q }
  { \Theta_1 \dotcup \Theta_2 \Vdash P \mid Q }

  \inferrule[Scope]
  { \Theta, c \tL \CH{A}, d \tL \HC{A} \vdash P }
  { \Theta \Vdash \scope{cd}{P} }
\end{mathpar}
\clearpage