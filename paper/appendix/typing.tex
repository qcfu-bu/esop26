In this section, we present the full typing rules of \TLLC{}. We organize the
typing rules into logical level, program level and process level.

\subsection{Logical Level}
The typing judgment for the logical level has the form $\Gamma \vdash m : A$.
This judgment states that under the \emph{logical context} $\Gamma$, term $m$
has type $A$. The logical level is completely \emph{structural}.

\paragraph{\textbf{Logical Context}}
The logical context $\Gamma$ is a sequence of variable bindings of the form 
$x_0 : A_0, x_1 : A_1, \dots, x_n : A_n$. Each variable $x_i$ is bound to a type $A_i$.
Variables in the logical context are unrestricted and can be used arbitrarily many
times. The empty context is denoted by $\epsilon$. To ensure the validity of types
in the logical context, we define the context validity judgment $\Gamma \vdash $.
\begin{mathpar}
  \inferrule[Ctx-Empty]
  { }
  { \epsilon \vdash }

  \inferrule[Ctx-Var]
  { \Gamma \vdash \quad \Gamma \vdash A : s \\
    x \notin \Gamma }
  { \Gamma, x : A \vdash }
\end{mathpar}
Note that the context validity judgment is \emph{mutually inductively} defined with the typing judgment. 

\paragraph{\textbf{Core Typing}}
Here we present the core typing rules for the logical level.
\begin{mathpar}\footnotesize
  \inferrule[Sort]
  { \Gamma \vdash }
  { \Gamma \vdash s : \Un }

  \inferrule[Var]
  { \Gamma, x : A \vdash }
  { \Gamma, x : A \vdash x : A }

  \inferrule[Explicit-Fun]
  { \Gamma \vdash A : s \\
    \Gamma, x : A \vdash B : r }
  { \Gamma \vdash \PiR{t}{x : A}{B} : t }

  \inferrule[Implicit-Fun]
  { \Gamma \vdash A : s \\
    \Gamma, x : A \vdash B : r }
  { \Gamma \vdash \PiI{t}{x : A}{B} : t }

  \inferrule[Explicit-Lam]
  { \Gamma, x : A \vdash m : B }
  { \Gamma \vdash \lamR{t}{x : A}{m} : \PiR{t}{x : A}{B} }

  \inferrule[Implicit-Lam]
  { \Gamma, x : A \vdash m : B }
  { \Gamma \vdash \lamI{t}{x : A}{m} : \PiI{t}{x : A}{B} }

  \inferrule[Explicit-App]
  { \Gamma \vdash m : \PiR{t}{x : A}{B} \\
    \Gamma \vdash n : A }
  { \Gamma \vdash \appR{m}{n} : B[n/x] }

  \inferrule[Implicit-App]
  { \Gamma \vdash m : \PiI{t}{x : A}{B} \\
    \Gamma \vdash n : A }
  { \Gamma \vdash \appI{m}{n} : B[n/x] }

  \inferrule[Explicit-Sum]
  { s \sqsubseteq t \\ r \sqsubseteq t \\
    \Gamma \vdash A : s \\
    \Gamma, x : A \vdash B : r }
  { \Gamma \vdash \SigR{t}{x : A}{B} : t }

  \inferrule[Implicit-Sum]
  { r \sqsubseteq t \\
    \Gamma \vdash A : s \\
    \Gamma, x : A \vdash B : r }
  { \Gamma \vdash \SigI{t}{x : A}{B} : t }

  \inferrule[Explicit-Pair]
  { \Gamma \vdash \SigR{t}{x : A}{B} : t \\
    \Gamma \vdash m : A \\
    \Gamma \vdash n : B[m/x] }
  { \Gamma \vdash \pairR{m}{n}{t} : \SigR{t}{x : A}{B} }

  \inferrule[Implicit-Pair]
  { \Gamma \vdash \SigI{t}{x : A}{B} : t \\
    \Gamma \vdash m : A \\
    \Gamma \vdash n : B[m/x] }
  { \Gamma \vdash \pairI{m}{n}{t} : \SigI{t}{x : A}{B} }

  \inferrule[Explicit-SumElim]
  { \Gamma, z : \SigR{t}{x : A}{B} \vdash C : s \\
    \Gamma \vdash m : \SigR{t}{x : A}{B} \\
    \Gamma, x : A, y : B \vdash n : C[\pairR{x}{y}{t}/z] }
  { \Gamma \vdash \SigElim{[z]C}{m}{[x,y]n} : C[m/z] }

  \inferrule[Implicit-SumElim]
  { \Gamma, z : \SigI{t}{x : A}{B} \vdash C : s \\
    \Gamma \vdash m : \SigI{t}{x : A}{B} \\
    \Gamma, x : A, y : B \vdash n : C[\pairI{x}{y}{t}/z] }
  { \Gamma \vdash \SigElim{[z]C}{m}{[x,y]n} : C[m/z] }

  \inferrule[Conversion]
  { \Gamma \vdash B : s \\
    \Gamma \vdash m : A \\
    A \simeq B }
  { \Gamma \vdash m : B }
\end{mathpar}

\paragraph{\textbf{Data Typing}}
The data typing rules govern the typing of base types such as the unit type and
the boolean type. The rules are presented below.
\begin{mathpar}\small
  \inferrule[Unit]
  { \Gamma \vdash }
  { \Gamma \vdash \unit : \Un }

  \inferrule[UnitVal]
  { \Gamma \vdash }
  { \Gamma \vdash \ii : \unit }

  \inferrule[Bool]
  { \Gamma \vdash }
  { \Gamma \vdash \Bool : \Un }

  \inferrule[True]
  { \Gamma \vdash }
  { \Gamma \vdash \bTrue : \Bool }

  \inferrule[False]
  { \Gamma \vdash }
  { \Gamma \vdash \bFalse : \Bool }\\

  \inferrule[BoolElim]
  { \Gamma, z : \Bool \vdash A : s \\
    \Gamma \vdash m : \Bool \\
    \Gamma \vdash n_1 : A[\bTrue/z] \\
    \Gamma \vdash n_2 : A[\bFalse/z] }
  { \Gamma \vdash \boolElim{[z]A}{m}{n_1}{n_2} : A[m/z] }\\
\end{mathpar}

\paragraph{\textbf{Monadic Typing}}
The monadic typing rules govern the composition of monadic computations.
The standard rules for monadic return and bind are presented below.
\begin{mathpar}\small
  \inferrule[$\C$Type]
  { \Gamma \vdash A : s }
  { \Gamma \vdash \CM{A} : \Ln }

  \inferrule[Return]
  { \Gamma \vdash m : A }
  { \Gamma \vdash \return{m} : \CM{A} }

  \inferrule[Bind]
  { \Gamma \vdash B : s \\
    \Gamma \vdash m : \CM{A} \\
    \Gamma, x : A \vdash n : \CM{B} }
  { \Gamma \vdash \letin{x}{m}{n} : \CM{B} }\\
\end{mathpar}

\paragraph{\textbf{Session Typing}}
The session typing rules govern the typing of protocol, channels and communication
primitives. The rules are presented below.
\begin{mathpar}\footnotesize
  \inferrule[Proto]
  { \Gamma \vdash }
  { \Gamma \vdash \Proto : \Un }

  \inferrule[End]
  { \Gamma \vdash }
  { \Gamma \vdash \End : \Proto }

  \inferrule[Explicit-Action]
  { \Gamma, x : A \vdash B : \Proto }
  { \Gamma \vdash \ActR{\rho}{x : A}{B} : \Proto }

  \inferrule[Implicit-Action]
  { \Gamma, x : A \vdash B : \Proto }
  { \Gamma \vdash \ActI{\rho}{x : A}{B} : \Proto }

  \inferrule[RecProto]
  { \Gamma, x : A \vdash m : A \\
    A~\arity{\Proto} \\ 
    m~\guard{x} }
  { \Gamma \vdash \fix{x : A}{m} : A }

  \inferrule[ChType]
  { \Gamma \vdash A : \Proto }
  { \Gamma \vdash \CH{A} : \Ln }

  \inferrule[HcType]
  { \Gamma \vdash A : \Proto }
  { \Gamma \vdash \HC{A} : \Ln }

  \inferrule[Channel-CH]
  { \Gamma \vdash \\
    \epsilon \vdash A : \Proto }
  { \Gamma \vdash c : \CH{A} }

  \inferrule[Channel-HC]
  { \Gamma \vdash \\
    \epsilon \vdash A : \Proto }
  { \Gamma \vdash c : \HC{A} }

  \inferrule[Fork]
  { \Gamma, x : \CH{A} \vdash m : \CM{\unit} }
  { \Gamma \vdash \fork{x : \CH{A}}{m} : \CM{\HC{A}} }

  \inferrule[Explicit-Send-CH]
  { \Gamma \vdash m : \CH{\ActR{!}{x : A}{B}} }
  { \Gamma \vdash \sendR{m} : \PiR{\Ln}{x : A}{\CM{\CH{B}}} }

  \inferrule[Explicit-Send-HC]
  { \Gamma \vdash m : \HC{\ActR{?}{x : A}{B}} }
  { \Gamma \vdash \sendR{m} : \PiR{\Ln}{x : A}{\CM{\HC{B}}} }

  \inferrule[Implicit-Send-CH]
  { \Gamma \vdash m : \CH{\ActI{!}{x : A}{B}} }
  { \Gamma \vdash \sendI{m} : \PiI{\Ln}{x : A}{\CM{\CH{B}}} }

  \inferrule[Implicit-Send-HC]
  { \Gamma \vdash m : \HC{\ActI{?}{x : A}{B}} }
  { \Gamma \vdash \sendI{m} : \PiI{\Ln}{x : A}{\CM{\HC{B}}} }

  \inferrule[Explicit-Recv-CH]
  { \Gamma \vdash m : \CH{\ActR{?}{x : A}{B}} }
  { \Gamma \vdash \recvR{m} : \CM{\SigR{\Ln}{x : A}{\CH{B}}} }

  \inferrule[Explicit-Recv-HC]
  { \Gamma \vdash m : \HC{\ActR{!}{x : A}{B}} }
  { \Gamma \vdash \recvR{m} : \CM{\SigR{\Ln}{x : A}{\HC{B}}} }

  \inferrule[Implicit-Recv-CH]
  { \Gamma \vdash m : \CH{\ActI{?}{x : A}{B}} }
  { \Gamma \vdash \recvI{m} : \CM{\SigI{\Ln}{x : A}{\CH{B}}} }

  \inferrule[Implicit-Recv-HC]
  { \Gamma \vdash m : \HC{\ActI{!}{x : A}{B}} }
  { \Gamma \vdash \recvI{m} : \CM{\SigI{\Ln}{x : A}{\HC{B}}} }

  \inferrule[Close]
  { \Gamma \vdash m : \CH{\End} }
  { \Gamma \vdash \close{m} : \CM{\unit} }

  \inferrule[Wait]
  { \Gamma \vdash m : \HC{\End} }
  { \Gamma \vdash \wait{m} : \CM{\unit} }
\end{mathpar}
\clearpage

\subsection{Program Level}
The typing judgment for the program level has the form $\Gamma ; \Delta \vdash m : A$.
This judgment states that under the logical context $\Gamma$ and the
\emph{program context} $\Delta$, term $m$ has type $A$.

\paragraph{\textbf{Program Context}}
The program context $\Delta$ is a sequence of variable bindings of the form
$x_0 :_{s_0} A_0, x_1 :_{s_1} A_1, \dots, x_n :_{s_n} A_n$. 
Each variable $x_i$ is bound to a type $A_i$ with a sort annotation $s_i$.
The variables in the program context are allowed to appear in computationally
relevant positions inside $m$. To ensure that all types appear in the program
context are well-formed, we define the program context validity judgment
$\Gamma ; \Delta \vdash $. The rules for this judgment are presented below.
\begin{mathpar}
  \inferrule[Ctx-Empty]
  { }
  { \epsilon ; \epsilon \vdash }

  \inferrule[Ctx-Implicit-Var]
  { \Gamma ; \Delta \vdash \\
    \Gamma \vdash A : s \\
    x \notin \Gamma }
  { \Gamma, x : A ; \Delta \vdash }

  \inferrule[Ctx-Explicit-Var]
  { \Gamma ; \Delta \vdash \\
    \Gamma \vdash A : s \\
    x \notin \Gamma }
  { \Gamma, x : A ; \Delta, x \ty{s} A \vdash }
\end{mathpar}
From these rules we can see that $\text{dom}(\Delta)$ is a subset of
$\text{dom}(\Gamma)$. Additionally, the sort annotation $s$ in each program
context binding $x \ty{s} A$ is the sort of the associated $A$ type.