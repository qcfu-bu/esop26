In this section, we present the operational semantics of \TLLC{}. 
Similarly to the typing rules, we organize the presentation of the semantics
into the logical level, program level, and process level.

\subsection{Logical Level}\label{appendix:logical-semantics}
The semantics of the logical level is defined in terms of the 
\emph{parallel reduction} relation $m \Rightarrow m'$. This relation allows 
multiple redexes to be reduced simultaneously.

\paragraph{\textbf{Core Reduction}}
The parallel reduction for core functional terms is defined as follows:
\begin{mathpar}\footnotesize
  \inferrule[PStep-Var]
  { }
  { x \Rightarrow x }

  \inferrule[PStep-Sort]
  { }
  { s \Rightarrow s }

  \inferrule[PStep-Explicit-Fun]
  { A \Rightarrow A' \\ B \Rightarrow B' }
  { \PiR{s}{x : A}{B} \Rightarrow \PiR{s}{x : A'}{B'} }

  \inferrule[PStep-Implicit-Fun]
  { A \Rightarrow A' \\ B \Rightarrow B' }
  { \PiI{s}{x : A}{B} \Rightarrow \PiI{s}{x : A'}{B'} }

  \inferrule[PStep-Explicit-Lam]
  { A \Rightarrow A' \\ B \Rightarrow B' }
  { \lamR{s}{x : A}{B} \Rightarrow \lamR{s}{x : A'}{B'} }

  \inferrule[PStep-Implicit-Lam]
  { A \Rightarrow A' \\ B \Rightarrow B' }
  { \lamI{s}{x : A}{B} \Rightarrow \lamI{s}{x : A'}{B'} }

  \inferrule[PStep-Explicit-App]
  { m \Rightarrow m' \\ n \Rightarrow n' }
  { \appR{m}{n} \Rightarrow \appR{m'}{n'} }

  \inferrule[PStep-Implicit-App]
  { m \Rightarrow m' \\ n \Rightarrow n' }
  { \appI{m}{n} \Rightarrow \appI{m'}{n'} }

  \inferrule[PStep-Explicit-$\beta$]
  { m \Rightarrow m' \\ n \Rightarrow n' }
  { \appR{(\lamR{s}{x : A}{m})}{n} \Rightarrow m'[n'/x] }

  \inferrule[PStep-Implicit-$\beta$]
  { m \Rightarrow m' \\ n \Rightarrow n' }
  { \appI{(\lamI{s}{x : A}{m})}{n} \Rightarrow m'[n'/x] }

  \inferrule[PStep-Explicit-Sum]
  { A \Rightarrow A' \\ B \Rightarrow B' }
  { \SigR{s}{x : A}{B} \Rightarrow \SigR{s}{x : A'}{B'} }

  \inferrule[PStep-Implicit-Sum]
  { A \Rightarrow A' \\ B \Rightarrow B' }
  { \SigI{s}{x : A}{B} \Rightarrow \SigI{s}{x : A'}{B'} }

  \inferrule[PStep-Explicit-Pair]
  { m \Rightarrow m' \\ n \Rightarrow n' }
  { \pairR{m}{n}{s} \Rightarrow \pairR{m'}{n'}{s} }

  \inferrule[PStep-Implicit-Pair]
  { m \Rightarrow m' \\ n \Rightarrow n' }
  { \pairI{m}{n}{s} \Rightarrow \pairI{m'}{n'}{s} }

  \inferrule[PStep-SumElim]
  { A \Rightarrow A' \\ m \Rightarrow m' \\ n \Rightarrow n' }
  { \SigElim{[z]A}{m}{[x,y]n} \Rightarrow \SigElim{[z]A'}{m'}{[x,y]n'} }

  \inferrule[PStep-Explicit-PairElim]
  { m_1 \Rightarrow m_1' \\ m_2 \Rightarrow m_2' \\ n \Rightarrow n' }
  { \SigElim{[z]A}{\pairR{m_1}{m_2}{s}}{[x,y]n} \Rightarrow n'[m_1/x,m_2/y] }

  \inferrule[PStep-Implicit-PairElim]
  { m_1 \Rightarrow m_1' \\ m_2 \Rightarrow m_2' \\ n \Rightarrow n' }
  { \SigElim{[z]A}{\pairI{m_1}{m_2}{s}}{[x,y]n} \Rightarrow n'[m_1/x,m_2/y] }
\end{mathpar}

\paragraph{\textbf{Data Reduction}}
The parallel reduction for data terms is defined as follows:
\begin{mathpar}\footnotesize
  \inferrule[PStep-Unit]
  { }
  { \unit \Rightarrow \unit }

  \inferrule[PStep-UnitVal]
  { }
  { \ii \Rightarrow \ii }

  \inferrule[PStep-Bool]
  { }
  { \Bool \Rightarrow \Bool }

  \inferrule[PStep-True]
  { }
  { \bTrue \Rightarrow \bTrue }

  \inferrule[PStep-False]
  { }
  { \bFalse \Rightarrow \bFalse }

  \inferrule[PStep-BoolElim]
  { A \Rightarrow A' \\
    m \Rightarrow m' \\
    n_1 \Rightarrow n_1' \\
    n_2 \Rightarrow n_2' }
  { \boolElim{[z]A}{m}{n_1}{n_2} \Rightarrow \boolElim{[z]A'}{m'}{n_1'}{n_2'} }

  \inferrule[PStep-TrueElim]
  { n_1 \Rightarrow n_1' }
  { \boolElim{[z]A}{\bTrue}{n_1}{n_2} \Rightarrow n_1' }

  \inferrule[PStep-FalseElim]
  { n_2 \Rightarrow n_2' }
  { \boolElim{[z]A}{\bFalse}{n_1}{n_2} \Rightarrow n_2' }
\end{mathpar}

\paragraph{\textbf{Monadic Reduction}}
The parallel reduction for monadic terms is defined as follows:
\begin{mathpar}\footnotesize
  \inferrule[PStep-$\mcC$Type]
  { A \Rightarrow A' }
  { \CM{A} \Rightarrow \CM{A'} }

  \inferrule[PStep-Return]
  { m \Rightarrow m' }
  { \return{m} \Rightarrow \return{m'} }

  \inferrule[PStep-Bind]
  { m \Rightarrow m' \\ n \Rightarrow n' }
  { \letin{x}{m}{n} \Rightarrow \letin{x}{m'}{n'} }

  \inferrule[PStep-ReturnBind]
  { m \Rightarrow m' \\ n \Rightarrow n' }
  { \letin{x}{\return{m}}{n} \Rightarrow n'[m'/x] }
\end{mathpar}
\clearpage

\paragraph{\textbf{Session Reduction}}
The parallel reduction for protocols, channels and concurrency primitives are defined as follows:
\begin{mathpar}\footnotesize
  \inferrule[PStep-Proto]
  { }
  { \Proto \Rightarrow \Proto }

  \inferrule[PStep-End]
  { }
  { \End \Rightarrow \End }

  \inferrule[PStep-RecProto]
  { A \Rightarrow A' \\ m \Rightarrow m' }
  { \fix{x : A}{m} \Rightarrow \fix{x : A'}{m'} }

  \inferrule[PStep-RecUnfold]
  { A \Rightarrow A' \\ m \Rightarrow m' }
  { \fix{x : A}{m} \Rightarrow m'[(\fix{x : A'}{m'})/x] }

  \inferrule[PStep-Explicit-Action]
  { A \Rightarrow A' \\ B \Rightarrow B' }
  { \ActR{\rho}{x : A}{B} \Rightarrow \ActR{\rho}{x : A'}{B'} }

  \inferrule[PStep-Implicit-Action]
  { A \Rightarrow A' \\ B \Rightarrow B' }
  { \ActI{\rho}{x : A}{B} \Rightarrow \ActI{\rho}{x : A'}{B'} }

  \inferrule[PStep-CH]
  { A \Rightarrow A' }
  { \CH{A} \Rightarrow \CH{A'} }

  \inferrule[PStep-HC]
  { A \Rightarrow A' }
  { \HC{A} \Rightarrow \HC{A'} }

  \inferrule[PStep-Channel]
  { }
  { c \Rightarrow d }

  \inferrule[PStep-Fork]
  { A \Rightarrow A' \\ m \Rightarrow m' }
  { \fork{x : A}{m} \Rightarrow \fork{x : A'}{m'} }

  \inferrule[PStep-Explicit-Send]
  { m \Rightarrow m' }
  { \sendR{m} \Rightarrow \sendR{m'} }

  \inferrule[PStep-Implicit-Send]
  { m \Rightarrow m' }
  { \sendI{m} \Rightarrow \sendI{m'} }

  \inferrule[PStep-Explicit-Recv]
  { m \Rightarrow m' }
  { \recvR{m} \Rightarrow \recvR{m'} }

  \inferrule[PStep-Implicit-Recv]
  { m \Rightarrow m' }
  { \recvI{m} \Rightarrow \recvI{m'} }

  \inferrule[PStep-Close]
  { m \Rightarrow m' }
  { \close{m} \Rightarrow \close{m'} }

  \inferrule[PStep-Wait]
  { m \Rightarrow m' }
  { \wait{m} \Rightarrow \wait{m'} }
\end{mathpar}

\paragraph{\textbf{Convertibility Relation}}
The convertibility relation $A \simeq B$ is the reflexive, symmetric and
transitive closure of the parallel reduction relation. It can be inductively
defined as follows:
\begin{mathpar}
  \inferrule[Conv-Refl]
  { }
  { A \simeq A }

  \inferrule[Conv-PStep]
  { A \simeq B \\ 
    B \Rightarrow C }
  { A \simeq C }

  \inferrule[Conv-PStep-Rev]
  { A \simeq B \\ 
    C \Rightarrow B }
  { A \simeq C }
\end{mathpar}
Note that the program level \textsc{Conversion} rule (\Cref{appendix:program-typing}) 
also uses this convertibility relation.
\clearpage

\subsection{Program Level}\label{appendix:program-semantics}
The semantics of the program level is defined in terms of a small-step reduction
relation $m \Leadsto m'$. Unlike the logical level which has a non-deterministic
reduction strategy, the program level follows call-by-value evaluation.
Arguments are fully evaluated before substitution into functions.

\paragraph{\textbf{Core Reduction}}
The small-step reduction for core functional terms is defined as follows:
\begin{mathpar}\footnotesize
  \inferrule[Step-Explicit-App$_1$]
  { m \Leadsto m' }
  { \appR{m}{n} \Leadsto \appR{m'}{n} }

  \inferrule[Step-Explicit-App$_2$]
  { n \Leadsto n' }
  { \appR{m}{n} \Leadsto \appR{m}{n'} }

  \inferrule[Step-Implicit-App$_1$]
  { m \Leadsto m' }
  { \appI{m}{n} \Leadsto \appI{m'}{n} }
  
  \inferrule[Step-Explicit-$\beta$]
  { }
  { \appR{(\lamR{s}{x : A}{m})}{v} \Leadsto m[v/x] }

  \inferrule[Step-Implicit-$\beta$]
  { }
  { \appI{(\lamI{s}{x : A}{m})}{n} \Leadsto m[n/x] }

  \inferrule[Step-Explicit-Pair$_1$]
  { m \Leadsto m' }
  { \pairR{m}{n}{s} \Leadsto \pairR{m'}{n}{s} }

  \inferrule[Step-Explicit-Pair$_2$]
  { n \Leadsto n' }
  { \pairR{m}{n}{s} \Leadsto \pairR{m}{n'}{s} }

  \inferrule[Step-Implicit-Pair$_2$]
  { n \Leadsto n' }
  { \pairI{m}{n}{s} \Leadsto \pairI{m}{n'}{s} }

  \inferrule[Step-SumElim$_1$]
  { m \Leadsto m' }
  { \SigElim{[z]A}{m}{[x,y]n} \Leadsto \SigElim{[z]A}{m'}{[x,y]n} }

  \inferrule[Step-Explicit-PairElim]
  { }
  { \SigElim{[z]A}{\pairR{u}{v}{s}}{[x,y]n} \Leadsto n[u/x,v/y] }

  \inferrule[Step-Implicit-PairElim]
  { }
  { \SigElim{[z]A}{\pairI{m}{v}{s}}{[x,y]n} \Leadsto n[m/x,v/y] }
\end{mathpar}

\paragraph{\textbf{Data Reduction}}
The small-step reduction for data terms is defined as follows:
\begin{mathpar}\small
  \inferrule[Step-BoolElim]
  { m \Leadsto m' }
  { \boolElim{[z]A}{m}{n_1}{n_2} \Leadsto \boolElim{[z]A}{m'}{n_1}{n_2} }

  \inferrule[Step-TrueElim]
  { }
  { \boolElim{[z]A}{\bTrue}{n_1}{n_2} \Leadsto n_1 }

  \inferrule[Step-FalseElim]
  { }
  { \boolElim{[z]A}{\bFalse}{n_1}{n_2} \Leadsto n_2 }
\end{mathpar}

\paragraph{\textbf{Monadic Reduction}}
The small-step reduction for monadic terms is defined as follows:
\begin{mathpar}\small
  \inferrule[Step-Return]
  { m \Leadsto m' }
  { \return{m} \Leadsto \return{m'} }

  \inferrule[Step-Bind]
  { m \Leadsto m' }
  { \letin{x}{m}{n} \Leadsto \letin{x}{m'}{n} }

  \inferrule[Step-ReturnBind]
  { }
  { \letin{x}{\return{v}}{n} \Leadsto n[v/x] }
\end{mathpar}

\paragraph{\textbf{Session Reduction}}
The small-step reduction for session terms is defined as follows:
\begin{mathpar}\small
  \inferrule[Step-Explicit-Send]
  { m \Leadsto m' }
  { \sendR{m} \Leadsto \sendR{m'} }

  \inferrule[Step-Implicit-Send]
  { m \Leadsto m' }
  { \sendI{m} \Leadsto \sendI{m'} }

  \inferrule[Step-Explicit-Recv]
  { m \Leadsto m' }
  { \recvR{m} \Leadsto \recvR{m'} }

  \inferrule[Step-Implicit-Recv]
  { m \Leadsto m' }
  { \recvI{m} \Leadsto \recvI{m'} }

  \inferrule[Step-Close]
  { m \Leadsto m' }
  { \close{m} \Leadsto \close{m'} }

  \inferrule[Step-Wait]
  { m \Leadsto m' }
  { \wait{m} \Leadsto \wait{m'} }
\end{mathpar}
\clearpage

\subsection{Process Level}\label{appendix:process-semantics}
The semantics of the process level is defined in terms of a small-step reduction
relation $P \Rrightarrow Q$. This relation is what gives \TLLC{} its concurrent
behavior. Before we present the reduction rules, we first define the notion of
\emph{structural congruence} $\equiv$ which identifies processes that are
the same up to reordering of parallel components and renaming of bound channels.

\paragraph{\textbf{Structural Congruence}}
The structural congruence relation $\equiv$ is defined as follows:
\begin{mathpar}\small
  P \mid Q \equiv Q \mid P 

  O \mid (P \mid Q) \equiv (O \mid P) \mid Q

  P \mid \proc{\return{\ii}} \equiv P
  \\
  \scope{cd}{P} \mid Q \equiv \scope{cd}{(P \mid Q)}

  \scope{cd}{P} \equiv \scope{dc}{P}

  \scope{cd}{\scope{c'd'}{P}} \equiv \scope{c'd'}{\scope{cd}{P}}
\end{mathpar}

\paragraph{\textbf{Process Reduction}}
The small-step reduction for processes is defined as follows:

\vspace{1em}
\begin{small}
\begin{tabular}{l L}
  (\textsc{Proc-Fork}) &
    \proc{\letin{x}{\fork{y : A}{m}}{n}}
    \Rrightarrow
    \scope{cd}{(\proc{n[c/x]} \mid \proc{m[d/y]})} 
  \\
  (\textsc{Proc-End}) 
    &\scope{cd}{(\proc{\letin{x}{\close{c}}{m}} \mid \proc{\letin{y}{\wait{d}}{n}})} \\
    &\quad\Rrightarrow 
     \proc{\letin{x}{\return{\ii}}{m}} \mid \proc{\letin{y}{\return{\ii}}{n}} 
  \\
  (\textsc{Proc-Com}) 
    &\scope{cd}{(\proc{\letin{x}{\appR{\sendR{c}}{v}}{m}} \mid \proc{\letin{y}{\recvR{d}}{n}})} \\
    &\quad\Rrightarrow 
     \scope{cd}{(\proc{\letin{x}{\return{c}}{m}} \mid \proc{\letin{y}{\return{\pairR{v}{d}{\Ln}}}{n}})}
  \\
  (\textsc{Proc-\underline{Com}}) 
    &\scope{cd}{(\proc{\letin{x}{\appI{\sendI{c}}{o}}{m}} \mid \proc{\letin{y}{\recvI{d}}{n}})} \\
    &\quad\Rrightarrow 
     \scope{cd}{(\proc{\letin{x}{\return{c}}{m}} \mid \proc{\letin{y}{\return{\pairI{o}{d}{\Ln}}}{n}})}
\end{tabular}
\vspace{0.2em}
\begin{mathpar}
  \inferrule[(Proc-Expr)]
  { m \Leadsto m' }
  { \proc{m} \Rrightarrow \proc{m'} }

  \inferrule[(Proc-Par)]
  { P \Rrightarrow Q }
  { O \mid P \Rrightarrow O \mid Q }

  \inferrule[(Proc-Scope)]
  { P \Rrightarrow Q }
  { \scope{cd}{P} \Rrightarrow \scope{cd}{Q} }

  \inferrule[(Proc-Congr)]
  { P \equiv P' \\ 
    P' \Rrightarrow Q' \\ 
    Q' \equiv Q }
  { P \Rrightarrow Q }
\end{mathpar}
\end{small}
\clearpage