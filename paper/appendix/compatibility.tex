To show that the \TLLC{} extensions made are compatible with the theory of TLL,
we prove the \TLLC{} terms enjoy the same properties as TLL ones. 

\paragraph{\textbf{Confluence}}
We show that the logical reduction relation is confluent. 
This property is important as it ensures that type convertibility can be checked
regardless of the order in which reductions are applied. 
Confluence is easy to prove here as the parallel reduction satisfies the diamond property.

\begin{lemma}[Diamond Property]\label[lemma]{lemma:diamond}
  If $m \Rightarrow m_1$ and $m \Rightarrow m_2$, then there exists $m'$ such that
  $m_1 \Rightarrow m'$ and $m_2 \Rightarrow m'$.
\end{lemma}
\begin{proof}
  By induction on the structure of the parallel reduction.
\end{proof}

\begin{lemma}\label[lemma]{lemma:strip}
  If $m \Rightarrow m_1$ and $m \Rightarrow^* m_2$, then there exists $m'$ such that
  $m_1 \Rightarrow^* m'$ and $m_2 \Rightarrow m'$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $m \Rightarrow^* m_2$ and \Cref{lemma:diamond}.
\end{proof}

\begin{theorem}[Confluence]
  If $m \Rightarrow^* m_1$ and $m \Rightarrow^* m_2$, then there exists $m'$ such that
  $m_1 \Rightarrow^* m'$ and $m_2 \Rightarrow^* m'$.
\end{theorem}
\begin{proof}
  By induction on the derivation of $m \Rightarrow^* m_2$ and \Cref{lemma:strip}.
\end{proof}

The validity of the confluence property allows us to prove the injectivity of
the convertibility relation for types.

\begin{corollary}\label[corollary]{corollary:inj-sort}
  $s_1 \simeq s_2$ implies $s_1 = s_2$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-implicit-fun}
  $\PiI{s}{x : A}{B} \simeq \PiI{s'}{x : A'}{B'}$ implies $s = s'$, $A \simeq A'$, and $B \simeq B'$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-explicit-fun}
  $\PiR{s}{x : A}{B} \simeq \PiR{s'}{x : A'}{B'}$ implies $s = s'$, $A \simeq A'$, and $B \simeq B'$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-implicit-sig}
  $\SigI{s}{x : A}{B} \simeq \SigI{s'}{x : A'}{B'}$ implies $s = s'$, $A \simeq A'$, and $B \simeq B'$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-explicit-sig}
  $\SigR{s}{x : A}{B} \simeq \SigR{s'}{x : A'}{B'}$ implies $s = s'$, $A \simeq A'$, and $B \simeq B'$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-monad}
  $\CM{A} \simeq \CM{B}$ implies $A \simeq B$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-implicit-action}
  $\ActI{\rho}{x : A}{B} \simeq \ActI{\rho'}{x : A'}{B'}$ implies $\rho = \rho'$, $A \simeq A'$, and $B \simeq B'$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-explicit-action}
  $\ActR{\rho}{x : A}{B} \simeq \ActR{\rho'}{x : A'}{B'}$ implies $\rho = \rho'$, $A \simeq A'$, and $B \simeq B'$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-ch}
  $\CH{A} \simeq \CH{B}$ implies $A \simeq B$. 
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-hc}
  $\HC{A} \simeq \HC{B}$ implies $A \simeq B$.
\end{corollary}

\paragraph{\textbf{Weakening}}
Weakening allows for the addition of unused variables to a typing context. 
The logical level type system allows weakening as it is a fully structural type system.
On the other hand, the program level type system only allows weakening of unrestricted variables, 
i.e. variables whose types inhabit $\Un$.

\begin{lemma}[Renaming Arity]
  Given renaming $\xi$, if there is $A~\arity{\Proto}$, then there is $A[\xi]~\arity{\Proto}$.
\end{lemma}
\begin{proof}
  By induction on the structure of $A$.
\end{proof}

\begin{lemma}[Renaming Guarded]
  Given renaming $\xi$, 
  if there is $\forall x, y, \xi(x) = \xi(y) \implies x = y$, 
  then given variable $x$ and $A~\guard{x}$, there is $A[\xi]~\guard{\xi(x)}$.
\end{lemma}
\begin{proof}
  By induction on the structure of $A$.
\end{proof}

\begin{lemma}[Logical Weakening]
  If $\Gamma \vdash m : A$ and $\Gamma \vdash B : s$, 
  then $\Gamma, x : B \vdash m : A$ where $x \not\in \Gamma$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\Gamma \vdash m : A$.
  For more details, see file \textsf{sta\_weak.v} of our Rocq development
  which uses a De Bruijn indices representation for variables.
\end{proof}

\begin{lemma}[Program Weakening (Explicit)]
  If $\Theta ; \Gamma ; \Delta \vdash m : A$ and $\Gamma \vdash B : \Un$,
  then $\Theta ; \Gamma, x : B ; \Delta, x :_\Un B \vdash m : A$ where $x \not\in \Gamma$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\Theta ; \Gamma ; \Delta \vdash m : A$.
  For more details, see file \textsf{dyn\_weak.v} of our Rocq development
  which uses a De Bruijn indices representation for variables.
\end{proof}

\begin{lemma}[Program Weakening (Implicit)]
  If $\Theta ; \Gamma ; \Delta \vdash m : A$ and $\Delta \vdash B : \Ln$,
  then $\Theta ; \Gamma, x : B ; \Delta \vdash m : A$ where $x \not\in \Delta$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\Theta ; \Gamma ; \Delta \vdash m : A$.
  For more details, see file \textsf{dyn\_weak.v} of our Rocq development
  which uses a De Bruijn indices representation for variables.
\end{proof}

\paragraph{\textbf{Substitution}}
The substitution lemma at the logical level is standard as the logical type system is
completely structural. The substitution lemma at the program level is more involved
as it needs to track linear variables in the program context.

\begin{lemma}[Substitution Arity]
  Given substitution $\sigma$, if there is $A~\arity{\Proto}$, then there is $A[\sigma]~\arity{\Proto}$.
\end{lemma}
\begin{proof}
  By induction on the structure of $A$.
\end{proof}

\begin{lemma}[Substitution Guarded]
  Given substitution $\sigma$ and variables $x, y$ and term $A$,
  if there is $\forall z, x \neq z \implies (\sigma\ z)~\guard{y}$
  and $A~\guard{x}$, then $A[\sigma]~\guard{y}$.
\end{lemma}
\begin{proof}
  By induction on the structure of $A$.
\end{proof}

\begin{lemma}[Logical Substitution]
  If $\Gamma, x : B \vdash m : A$ and $\Gamma \vdash n : B$, then $\Gamma \vdash m[n/x] : A[n/x]$.
\end{lemma}
\begin{proof}
  This lemma is proved through a more general lemma involving simultaneous substitutions. 
  For more details, see file \textsf{sta\_subst.v} of our Rocq development.
\end{proof}

\begin{corollary}
  If $\Gamma, x : A \vdash m : C$ and $A \simeq B$, then $\Gamma, x : B \vdash m : C$.
\end{corollary}

\begin{lemma}[Program Substitution (Explicit)]
  If ${\Theta_1 ; \Gamma, x : B ; \Delta_1, x :_s B \vdash m : A}$ and
  ${\Theta_2 ; \Gamma ; \Delta_2 \vdash n : B}$, then
  ${\Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash m[n/x] : A[n/x]}$.
\end{lemma}
\begin{proof}
  This lemma is proved through a more general lemma involving simultaneous substitutions. 
  For more details, see file \textsf{dyn\_subst.v} of our Rocq development.
\end{proof}

\begin{corollary}
  If $\Theta ; \Gamma, x : A ; \Delta \vdash m : C$ and 
  $A \simeq B$, then $\Theta ; \Gamma, x : B ; \Delta \vdash m : C$.
\end{corollary}

\begin{lemma}[Program Substitution (Implicit)]
  If ${\Theta ; \Gamma, x : B ; \Delta \vdash m : A}$ and
  ${\Gamma \vdash n : B}$, then ${\Theta ; \Gamma ; \Delta \vdash m[n/x] : A[n/x]}$.
\end{lemma}
\begin{proof}
  This lemma is proved through a more general lemma involving simultaneous substitutions. 
  For more details, see file \textsf{dyn\_subst.v} of our Rocq development.
\end{proof}

\begin{corollary}
  If ${\Theta ; \Gamma, x : A ; \Delta, x :_s A \vdash m : C}$ and
  $A \simeq B$, then ${\Theta ; \Gamma, x : B ; \Delta, x :_s B \vdash m : C}$.
\end{corollary}

\paragraph{\textbf{Sort Uniqueness}}
Due to the fact that \TLLC{} utilizes the sort of types to determine
(sub)structural properties of their inhabitants, it is important for types
to have unique sorts. If a type could have multiple sorts, then it would be
ambiguous whether its inhabitants are linear or unrestricted.

One of the main challenges in proving sort uniqueness is that there is no
uniqueness of types in general. In particular, dependent pairs like $\pairI{m}{n}{s}$
do not have unique typing. For this reason, we prove a weaker property of
\emph{type similarity} instead of type uniqueness. Then from type similarity
we can derive sort uniqueness. We begin by defining the \emph{head similarity}
relation as follows:
\begin{mathpar}\footnotesize
  \inferrule  
  { }
  { \HeadSim{x}{x} }

  \inferrule
  { }
  { \HeadSim{s}{s} }

  \inferrule
  { \HeadSim{B_1}{B_2} }
  { \HeadSim{\PiR{s}{x : A_1}{B_1}}{\PiR{s}{x : A_2}{B_2}} }

  \inferrule
  { \HeadSim{B_1}{B_2} }
  { \HeadSim{\PiI{s}{x : A_1}{B_1}}{\PiI{s}{x : A_2}{B_2}} }

  \inferrule
  { }
  { \HeadSim{\lamR{s}{x : A}{m}}{\lamR{s}{x : A}{m}} }

  \inferrule
  { }
  { \HeadSim{\lamI{s}{x : A}{m}}{\lamI{s}{x : A}{m}} }

  \inferrule
  { }
  { \HeadSim{\appR{m}{n}}{\appR{m}{n}} }

  \inferrule
  { }
  { \HeadSim{\appI{m}{n}}{\appI{m}{n}} }

  \inferrule
  { }
  { \HeadSim{\SigR{s}{x : A_1}{B_1}}{\SigR{s}{x : A_2}{B_2}} }

  \inferrule
  { }
  { \HeadSim{\SigI{s}{x : A_1}{B_1}}{\SigI{s}{x : A_2}{B_2}} }

  \inferrule
  { }
  { \HeadSim{\pairR{m}{n}{s}}{\pairR{m}{n}{s}} }

  \inferrule
  { }
  { \HeadSim{\pairI{m}{n}{s}}{\pairI{m}{n}{s}} }

  \inferrule
  { }
  { \HeadSim{\SigElim{[z]A}{m}{[x,y]n}}{\SigElim{[z]A}{m}{[x,y]n}} }

  \inferrule
  { }
  { \HeadSim{\fix{x : A}{m}}{\fix{x : A}{m}} }

  \inferrule
  { }
  { \HeadSim{\unit}{\unit} }

  \inferrule
  { }
  { \HeadSim{\ii}{\ii} }

  \inferrule
  { }
  { \HeadSim{\Bool}{\Bool} }

  \inferrule
  { }
  { \HeadSim{\bTrue}{\bTrue} }

  \inferrule
  { }
  { \HeadSim{\bFalse}{\bFalse} }

  \inferrule
  { }
  { \HeadSim{\boolElim{[z]A}{m}{n_1}{n_2}}{\boolElim{[z]A}{m}{n_1}{n_2}} }

  \inferrule
  { }
  { \HeadSim{\CM{A}}{\CM{B}} }

  \inferrule
  { }
  { \HeadSim{\return{m}}{\return{m}} }

  \inferrule
  { }
  { \HeadSim{\letin{m}{x}{n}}{\letin{m}{x}{n}} }

  \inferrule
  { }
  { \HeadSim{\Proto}{\Proto} }

  \inferrule
  { }
  { \HeadSim{\End}{\End} }

  \inferrule
  { }
  { \HeadSim{\ActR{\rho}{x : A}{B}}{\ActR{\rho}{x : A}{B}} }

  \inferrule
  { }
  { \HeadSim{\ActI{\rho}{x : A}{B}}{\ActI{\rho}{x : A}{B}} }

  \inferrule
  { }
  { \HeadSim{\CH{A}}{\CH{B}} }

  \inferrule
  { }
  { \HeadSim{\HC{A}}{\HC{B}} }

  \inferrule
  { }
  { \HeadSim{c}{c} }

  \inferrule
  { }
  { \HeadSim{\fork{x : A}{m}}{\fork{x : A}{m}} }

  \inferrule
  { }
  { \HeadSim{\recvR{m}}{\recvR{m}} }

  \inferrule
  { }
  { \HeadSim{\recvI{m}}{\recvI{m}} }

  \inferrule
  { }
  { \HeadSim{\sendR{m}}{\sendR{m}} }

  \inferrule
  { }
  { \HeadSim{\sendI{m}}{\sendI{m}} }

  \inferrule
  { }
  { \HeadSim{\close{m}}{\close{m}} }

  \inferrule
  { }
  { \HeadSim{\wait{m}}{\wait{m}} }
\end{mathpar}

We then define the \emph{type similarity} relation as follows:
\begin{align*}
  \Sim{A}{B} \triangleq \exists A', B', A \simeq A' \land B \simeq B' \land \HeadSim{A'}{B'}
\end{align*}

The similarity relation is naturally extended to typing contexts as follows:
\begin{mathpar}
  \inferrule 
  { }
  { \Sim{\epsilon}{\epsilon} }

  \inferrule 
  { \Sim{A}{B} \\ 
    \Sim{\Gamma_1}{\Gamma_2} }
  { \Sim{(\Gamma_1, x : A)}{(\Gamma_2, x : B)} }
\end{mathpar}

The (head) similarity relation enjoys the following properties.
\begin{lemma}[HeadSim Reflexive]\label[lemma]{lemma:headsim-reflexive}
  For any term $A$, there is $\HeadSim{A}{A}$.
\end{lemma}
\begin{proof}
  By induction on the structure of $A$.
\end{proof}

\begin{lemma}[HeadSim Symmetric]\label[lemma]{lemma:headsim-symmetric}
  For any $\HeadSim{A}{B}$, there is $\HeadSim{B}{A}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\HeadSim{A}{B}$.
\end{proof}

\begin{lemma}[HeadSim Substitution]\label[lemma]{lemma:headsim-substitution}
  Given substitution $\sigma$, if there is $\HeadSim{A}{B}$, then there is $\HeadSim{A[\sigma]}{B[\sigma]}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\HeadSim{A}{B}$.
\end{proof}

\begin{lemma}[Sim Reflexive]\label[lemma]{lemma:sim-reflexive}
  For any term $A$, there is $\Sim{A}{A}$.
\end{lemma}
\begin{proof}
  By the reflexivity of $\simeq$ and \Cref{lemma:headsim-reflexive}.
\end{proof}

\begin{lemma}[Sim Transitive Left]
  For any $\Sim{A}{B}$ and $B \simeq C$, there is $\Sim{A}{C}$.
\end{lemma}
\begin{proof}
  By the transitivity of $\simeq$.
\end{proof}

\begin{lemma}[Sim Transitive Right]
  For any $\Sim{A}{B}$ and $A \simeq C$, there is $\Sim{C}{B}$.
\end{lemma}
\begin{proof}
  By the transitivity of $\simeq$.
\end{proof}

\begin{lemma}[Sim Symmetric]
  For any $\Sim{A}{B}$, there is $\Sim{B}{A}$.
\end{lemma}
\begin{proof}
  By the symmetry of $\simeq$ and \Cref{lemma:headsim-symmetric}.
\end{proof}

\begin{lemma}[Sim Substitution]
  Given substitution $\sigma$, if there is $\Sim{A}{B}$, then there is $\Sim{A[\sigma]}{B[\sigma]}$.
\end{lemma}
\begin{proof}
  By the substitutivity of $\simeq$ and \Cref{lemma:headsim-substitution}.
\end{proof}

\begin{lemma}[Sim Sort Injective]\label[lemma]{lemma:sim-sort-injective}
  If $\Sim{s_1}{s_2}$, then $s_1 = s_2$.
\end{lemma}
\begin{proof}
  By the definition of similarity and \Cref{corollary:inj-sort}.
\end{proof}

\begin{lemma}[Type Similarity]\label[lemma]{lemma:type-similarity}
  Given $\Gamma_1 \vdash m : A$ and $\Gamma_2 \vdash m : B$ and $\Sim{\Gamma_1}{\Gamma_2}$,
  then $\Sim{A}{B}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\Gamma_1 \vdash m : A$.
\end{proof}

\begin{theorem}[Sort Uniqueness]\label[theorem]{theorem:sort-uniqueness}
  Given $\Gamma \vdash m : s$ and $\Gamma \vdash m : t$, then $s = t$.
\end{theorem}
\begin{proof}
  From \Cref{lemma:headsim-reflexive} we have $\Sim{\Gamma}{\Gamma}$.
  Then from \Cref{lemma:type-similarity} we have $\Sim{s}{t}$.
  Finally from \Cref{lemma:sim-sort-injective} we have $s = t$.
\end{proof}

\paragraph{\textbf{Inversion}}
Due to the presence of type conversion, inversion lemmas are necessary to reason about
typing derivations.

\begin{lemma}\label[lemma]{lemma:logical-inversion-explicit-fun}
  If $\Gamma \vdash \PiR{s}{x : A}{B} : C$, then there exists $t$
  such that $\Gamma, x : A \vdash B : t$ and $C \simeq s$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\Gamma \vdash \PiI{s}{x : A}{B} : C$.
\end{proof}

\begin{lemma}\label[lemma]{lemma:logical-inversion-implicit-fun}
  If $\Gamma \vdash \PiI{s}{x : A}{B} : C$, then there exists $t$
  such that $\Gamma, x : A \vdash B : t$ and $C \simeq s$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\Gamma \vdash \PiI{s}{x : A}{B} : C$.
\end{proof}

\begin{lemma}\label[lemma]{lemma:logical-inversion-explicit-sig}
  If $\Gamma \vdash \SigR{t}{x : A}{B} : C$, then there exists $s, r$ such that
  $s \sqsubseteq t$ and $r \sqsubseteq t$ and
  $\Gamma \vdash A : s$ and $\Gamma, x : A \vdash B : r$ and $C \simeq t$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\Gamma \vdash \SigR{t}{x : A}{B} : C$.
\end{proof}

\begin{lemma}\label[lemma]{lemma:logical-inversion-implicit-sig}
  If $\Gamma \vdash \SigI{t}{x : A}{B} : C$, then there exists $s, r$ such that
  $r \sqsubseteq t$ and
  $\Gamma \vdash A : s$ and $\Gamma, x : A \vdash B : r$ and $C \simeq t$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\Gamma \vdash \SigI{t}{x : A}{B} : C$.
\end{proof}

\paragraph{\textbf{Type Validity}}
We show that all types appearing in typing judgments are valid, i.e. they are well-sorted
at the logical level.

\begin{theorem}[Logical Type Validity]\label[theorem]{theorem:logical-type-validity}
  If $\Gamma \vdash m : A$, then there exists $s$ such that $\Gamma \vdash A : s$.
\end{theorem}
\begin{proof}
  By induction on the derivation of $\Gamma \vdash m : A$. We will show some representative cases.

\textbf{Case} (\textsc{Var}): 
  From the premise we have $\Gamma, x : A \vdash$ which implies $\Gamma \vdash A : s$ for some $s$.

\textbf{Case} (\textsc{Explicit-Lam}):
  From the induction hypothesis we have $\Gamma, x : A \vdash B : r$ for some $r$.
  The validity of context $\Gamma, x : A \vdash$ implies $\Gamma \vdash A : s$ for some $s$.
  Then from \textsc{Explicit-Fun} we have $\Gamma \vdash \PiR{s}{x : A}{B} : s$ which concludes this case.

\textbf{Case} (\textsc{Explicit-App}):
  From the induction hypothesis we have $\Gamma \vdash \PiR{s}{x : A}{B} : r$ for some $r$.
  From \Cref{lemma:logical-inversion-explicit-fun} we have $\Gamma, x : A \vdash B : t$ for some $t$ and $r \simeq s$.
\end{proof}