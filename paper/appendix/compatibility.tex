To show that the \TLLC{} extensions made are compatible with the theory of TLL,
we prove the \TLLC{} terms enjoy the same properties as TLL ones. 

\paragraph{\textbf{Confluence}}
We show that the logical reduction relation is confluent. 
This property is important as it ensures that type convertibility can be checked
regardless of the order in which reductions are applied. 
Confluence is easy to prove here as the parallel reduction satisfies the diamond property.

\begin{lemma}[Diamond Property]\label[lemma]{lemma:diamond}
  If $m \Rightarrow m_1$ and $m \Rightarrow m_2$, then there exists $m'$ such that
  $m_1 \Rightarrow m'$ and $m_2 \Rightarrow m'$.
\end{lemma}
\begin{proof}
  By induction on the structure of the parallel reduction.
\end{proof}

\begin{lemma}\label[lemma]{lemma:strip}
  If $m \Rightarrow m_1$ and $m \Rightarrow^* m_2$, then there exists $m'$ such that
  $m_1 \Rightarrow^* m'$ and $m_2 \Rightarrow m'$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $m \Rightarrow^* m_2$ and \Cref{lemma:diamond}.
\end{proof}

\begin{theorem}[Confluence]
  If $m \Rightarrow^* m_1$ and $m \Rightarrow^* m_2$, then there exists $m'$ such that
  $m_1 \Rightarrow^* m'$ and $m_2 \Rightarrow^* m'$.
\end{theorem}
\begin{proof}
  By induction on the derivation of $m \Rightarrow^* m_2$ and \Cref{lemma:strip}.
\end{proof}

The validity of the confluence property allows us to prove the injectivity of
the convertibility relation for types.

\begin{corollary}\label[corollary]{corollary:inj-sort}
  $s_1 \simeq s_2$ implies $s_1 = s_2$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-implicit-fun}
  $\PiI{s}{x : A}{B} \simeq \PiI{s'}{x : A'}{B'}$ implies $s = s'$, $A \simeq A'$, and $B \simeq B'$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-explicit-fun}
  $\PiR{s}{x : A}{B} \simeq \PiR{s'}{x : A'}{B'}$ implies $s = s'$, $A \simeq A'$, and $B \simeq B'$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-implicit-sig}
  $\SigI{s}{x : A}{B} \simeq \SigI{s'}{x : A'}{B'}$ implies $s = s'$, $A \simeq A'$, and $B \simeq B'$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-explicit-sig}
  $\SigR{s}{x : A}{B} \simeq \SigR{s'}{x : A'}{B'}$ implies $s = s'$, $A \simeq A'$, and $B \simeq B'$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-monad}
  $\CM{A} \simeq \CM{B}$ implies $A \simeq B$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-implicit-action}
  $\ActI{\rho}{x : A}{B} \simeq \ActI{\rho'}{x : A'}{B'}$ implies $\rho = \rho'$, $A \simeq A'$, and $B \simeq B'$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-explicit-action}
  $\ActR{\rho}{x : A}{B} \simeq \ActR{\rho'}{x : A'}{B'}$ implies $\rho = \rho'$, $A \simeq A'$, and $B \simeq B'$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-ch}
  $\CH{A} \simeq \CH{B}$ implies $A \simeq B$. 
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-hc}
  $\HC{A} \simeq \HC{B}$ implies $A \simeq B$.
\end{corollary}

\paragraph{\textbf{Weakening}}
Weakening allows for the addition of unused variables to a typing context. 
The logical level type system allows weakening as it is a fully structural type system.
On the other hand, the program level type system only allows weakening of unrestricted variables, 
i.e. variables whose types inhabit $\Un$.

\begin{lemma}[Renaming Arity]
  Given renaming $\xi$, if there is $A~\arity{\Proto}$, then there is $A[\xi]~\arity{\Proto}$.
\end{lemma}
\begin{proof}
  By induction on the structure of $A$.
\end{proof}

\begin{lemma}[Renaming Guarded]
  Given renaming $\xi$, 
  if there is $\forall x, y, \xi(x) = \xi(y) \implies x = y$, 
  then given variable $x$ and $A~\guard{x}$, there is $A[\xi]~\guard{\xi(x)}$.
\end{lemma}
\begin{proof}
  By induction on the structure of $A$.
\end{proof}

\begin{lemma}[Logical Weakening]
  If $\Gamma \vdash m : A$ and $\Gamma \vdash B : s$, 
  then $\Gamma, x : B \vdash m : A$ where $x \not\in \Gamma$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\Gamma \vdash m : A$.
  For more details, see file \textsf{sta\_weak.v} of our Rocq development
  which uses a De Bruijn indices representation for variables.
\end{proof}

\begin{lemma}[Program Weakening (Explicit)]
  If $\Theta ; \Gamma ; \Delta \vdash m : A$ and $\Gamma \vdash B : \Un$,
  then $\Theta ; \Gamma, x : B ; \Delta, x :_\Un B \vdash m : A$ where $x \not\in \Gamma$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\Theta ; \Gamma ; \Delta \vdash m : A$.
  For more details, see file \textsf{dyn\_weak.v} of our Rocq development
  which uses a De Bruijn indices representation for variables.
\end{proof}

\begin{lemma}[Program Weakening (Implicit)]
  If $\Theta ; \Gamma ; \Delta \vdash m : A$ and $\Delta \vdash B : \Ln$,
  then $\Theta ; \Gamma, x : B ; \Delta \vdash m : A$ where $x \not\in \Delta$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\Theta ; \Gamma ; \Delta \vdash m : A$.
  For more details, see file \textsf{dyn\_weak.v} of our Rocq development
  which uses a De Bruijn indices representation for variables.
\end{proof}

\paragraph{\textbf{Substitution}}
The substitution lemma at the logical level is standard as the logical type system is
completely structural. The substitution lemma at the program level is more involved
as it needs to track linear variables in the program context.

\begin{lemma}[Substitution Arity]\label[lemma]{lemma:subst-arity}
  Given substitution $\sigma$, if there is $A~\arity{\Proto}$, then there is $A[\sigma]~\arity{\Proto}$.
\end{lemma}
\begin{proof}
  By induction on the structure of $A$.
\end{proof}

\begin{lemma}[Substitution Guarded]\label[lemma]{lemma:subst-guard}
  Given substitution $\sigma$ and variables $x, y$ and term $A$,
  if there is $\forall z, x \neq z \implies (\sigma\ z)~\guard{y}$
  and $A~\guard{x}$, then $A[\sigma]~\guard{y}$.
\end{lemma}
\begin{proof}
  By induction on the structure of $A$.
\end{proof}

\begin{lemma}[Logical Substitution]\label[lemma]{lemma:logical-subst}
  If $\Gamma, x : B \vdash m : A$ and $\Gamma \vdash n : B$, then $\Gamma \vdash m[n/x] : A[n/x]$.
\end{lemma}
\begin{proof}
  This lemma is proved through a more general lemma involving simultaneous substitutions. 
  For more details, see file \textsf{sta\_subst.v} of our Rocq development.
\end{proof}

\begin{corollary}\label[corollary]{corollary:logical-context-conv}
  If $\Gamma, x : A \vdash m : C$ and $A \simeq B$, then $\Gamma, x : B \vdash m : C$.
\end{corollary}

\begin{lemma}[Program Substitution (Explicit)]\label[lemma]{lemma:program-subst-explicit}
  If ${\Theta_1 ; \Gamma, x : B ; \Delta_1, x :_s B \vdash m : A}$ and
  ${\Theta_2 ; \Gamma ; \Delta_2 \vdash n : B}$ and $\Theta_2 \triangleright s$ and $\Delta_2 \triangleright s$, then
  ${\Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash m[n/x] : A[n/x]}$.
\end{lemma}
\begin{proof}
  This lemma is proved through a more general lemma involving simultaneous substitutions. 
  For more details, see file \textsf{dyn\_subst.v} of our Rocq development.
\end{proof}

\begin{corollary}\label[corollary]{corollary:program-context-conv-explicit}
  If $\Theta ; \Gamma, x : A ; \Delta \vdash m : C$ and 
  $A \simeq B$, then $\Theta ; \Gamma, x : B ; \Delta \vdash m : C$.
\end{corollary}

\begin{lemma}[Program Substitution (Implicit)]\label[lemma]{lemma:program-subst-implicit}
  If ${\Theta ; \Gamma, x : B ; \Delta \vdash m : A}$ and
  ${\Gamma \vdash n : B}$, then ${\Theta ; \Gamma ; \Delta \vdash m[n/x] : A[n/x]}$.
\end{lemma}
\begin{proof}
  This lemma is proved through a more general lemma involving simultaneous substitutions. 
  For more details, see file \textsf{dyn\_subst.v} of our Rocq development.
\end{proof}

\begin{corollary}\label[corollary]{corollary:program-context-conv-implicit}
  If ${\Theta ; \Gamma, x : A ; \Delta, x :_s A \vdash m : C}$ and
  $A \simeq B$, then ${\Theta ; \Gamma, x : B ; \Delta, x :_s B \vdash m : C}$.
\end{corollary}

\paragraph{\textbf{Sort Uniqueness}}
Due to the fact that \TLLC{} utilizes the sort of types to determine
(sub)structural properties of their inhabitants, it is important for types
to have unique sorts. If a type could have multiple sorts, then it would be
ambiguous whether its inhabitants are linear or unrestricted.

One of the main challenges in proving sort uniqueness is that there is no
uniqueness of types in general. In particular, dependent pairs like $\pairI{m}{n}{s}$
do not have unique typing. For this reason, we prove a weaker property of
\emph{type similarity} instead of type uniqueness. Then from type similarity
we can derive sort uniqueness. We begin by defining the \emph{head similarity}
relation as follows:
\begin{mathpar}\footnotesize
  \inferrule  
  { }
  { \HeadSim{x}{x} }

  \inferrule
  { }
  { \HeadSim{s}{s} }

  \inferrule
  { \HeadSim{B_1}{B_2} }
  { \HeadSim{\PiR{s}{x : A_1}{B_1}}{\PiR{s}{x : A_2}{B_2}} }

  \inferrule
  { \HeadSim{B_1}{B_2} }
  { \HeadSim{\PiI{s}{x : A_1}{B_1}}{\PiI{s}{x : A_2}{B_2}} }

  \inferrule
  { }
  { \HeadSim{\lamR{s}{x : A}{m}}{\lamR{s}{x : A}{m}} }

  \inferrule
  { }
  { \HeadSim{\lamI{s}{x : A}{m}}{\lamI{s}{x : A}{m}} }

  \inferrule
  { }
  { \HeadSim{\appR{m}{n}}{\appR{m}{n}} }

  \inferrule
  { }
  { \HeadSim{\appI{m}{n}}{\appI{m}{n}} }

  \inferrule
  { }
  { \HeadSim{\SigR{s}{x : A_1}{B_1}}{\SigR{s}{x : A_2}{B_2}} }

  \inferrule
  { }
  { \HeadSim{\SigI{s}{x : A_1}{B_1}}{\SigI{s}{x : A_2}{B_2}} }

  \inferrule
  { }
  { \HeadSim{\pairR{m}{n}{s}}{\pairR{m}{n}{s}} }

  \inferrule
  { }
  { \HeadSim{\pairI{m}{n}{s}}{\pairI{m}{n}{s}} }

  \inferrule
  { }
  { \HeadSim{\SigElim{[z]A}{m}{[x,y]n}}{\SigElim{[z]A}{m}{[x,y]n}} }

  \inferrule
  { }
  { \HeadSim{\fix{x : A}{m}}{\fix{x : A}{m}} }

  \inferrule
  { }
  { \HeadSim{\unit}{\unit} }

  \inferrule
  { }
  { \HeadSim{\ii}{\ii} }

  \inferrule
  { }
  { \HeadSim{\Bool}{\Bool} }

  \inferrule
  { }
  { \HeadSim{\bTrue}{\bTrue} }

  \inferrule
  { }
  { \HeadSim{\bFalse}{\bFalse} }

  \inferrule
  { }
  { \HeadSim{\boolElim{[z]A}{m}{n_1}{n_2}}{\boolElim{[z]A}{m}{n_1}{n_2}} }

  \inferrule
  { }
  { \HeadSim{\CM{A}}{\CM{B}} }

  \inferrule
  { }
  { \HeadSim{\return{m}}{\return{m}} }

  \inferrule
  { }
  { \HeadSim{\letin{m}{x}{n}}{\letin{m}{x}{n}} }

  \inferrule
  { }
  { \HeadSim{\Proto}{\Proto} }

  \inferrule
  { }
  { \HeadSim{\End}{\End} }

  \inferrule
  { }
  { \HeadSim{\ActR{\rho}{x : A}{B}}{\ActR{\rho}{x : A}{B}} }

  \inferrule
  { }
  { \HeadSim{\ActI{\rho}{x : A}{B}}{\ActI{\rho}{x : A}{B}} }

  \inferrule
  { }
  { \HeadSim{\CH{A}}{\CH{B}} }

  \inferrule
  { }
  { \HeadSim{\HC{A}}{\HC{B}} }

  \inferrule
  { }
  { \HeadSim{c}{c} }

  \inferrule
  { }
  { \HeadSim{\fork{x : A}{m}}{\fork{x : A}{m}} }

  \inferrule
  { }
  { \HeadSim{\recvR{m}}{\recvR{m}} }

  \inferrule
  { }
  { \HeadSim{\recvI{m}}{\recvI{m}} }

  \inferrule
  { }
  { \HeadSim{\sendR{m}}{\sendR{m}} }

  \inferrule
  { }
  { \HeadSim{\sendI{m}}{\sendI{m}} }

  \inferrule
  { }
  { \HeadSim{\close{m}}{\close{m}} }

  \inferrule
  { }
  { \HeadSim{\wait{m}}{\wait{m}} }
\end{mathpar}

We then define the \emph{type similarity} relation as follows:
\begin{align*}
  \Sim{A}{B} \triangleq \exists A', B', A \simeq A' \land B \simeq B' \land \HeadSim{A'}{B'}
\end{align*}

The similarity relation is naturally extended to typing contexts as follows:
\begin{mathpar}
  \inferrule 
  { }
  { \Sim{\epsilon}{\epsilon} }

  \inferrule 
  { \Sim{A}{B} \\ 
    \Sim{\Gamma_1}{\Gamma_2} }
  { \Sim{(\Gamma_1, x : A)}{(\Gamma_2, x : B)} }
\end{mathpar}

The (head) similarity relation enjoys the following properties.
\begin{lemma}[HeadSim Reflexive]\label[lemma]{lemma:headsim-reflexive}
  For any term $A$, there is $\HeadSim{A}{A}$.
\end{lemma}
\begin{proof}
  By induction on the structure of $A$.
\end{proof}

\begin{lemma}[HeadSim Symmetric]\label[lemma]{lemma:headsim-symmetric}
  For any $\HeadSim{A}{B}$, there is $\HeadSim{B}{A}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\HeadSim{A}{B}$.
\end{proof}

\begin{lemma}[HeadSim Substitution]\label[lemma]{lemma:headsim-substitution}
  Given substitution $\sigma$, if there is $\HeadSim{A}{B}$, then there is $\HeadSim{A[\sigma]}{B[\sigma]}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\HeadSim{A}{B}$.
\end{proof}

\begin{lemma}[Sim Reflexive]\label[lemma]{lemma:sim-reflexive}
  For any term $A$, there is $\Sim{A}{A}$.
\end{lemma}
\begin{proof}
  By the reflexivity of $\simeq$ and \Cref{lemma:headsim-reflexive}.
\end{proof}

\begin{lemma}[Sim Transitive Left]
  For any $\Sim{A}{B}$ and $B \simeq C$, there is $\Sim{A}{C}$.
\end{lemma}
\begin{proof}
  By the transitivity of $\simeq$.
\end{proof}

\begin{lemma}[Sim Transitive Right]
  For any $\Sim{A}{B}$ and $A \simeq C$, there is $\Sim{C}{B}$.
\end{lemma}
\begin{proof}
  By the transitivity of $\simeq$.
\end{proof}

\begin{lemma}[Sim Symmetric]
  For any $\Sim{A}{B}$, there is $\Sim{B}{A}$.
\end{lemma}
\begin{proof}
  By the symmetry of $\simeq$ and \Cref{lemma:headsim-symmetric}.
\end{proof}

\begin{lemma}[Sim Substitution]
  Given substitution $\sigma$, if there is $\Sim{A}{B}$, then there is $\Sim{A[\sigma]}{B[\sigma]}$.
\end{lemma}
\begin{proof}
  By the substitutivity of $\simeq$ and \Cref{lemma:headsim-substitution}.
\end{proof}

\begin{lemma}[Sim Sort Injective]\label[lemma]{lemma:sim-sort-injective}
  If $\Sim{s_1}{s_2}$, then $s_1 = s_2$.
\end{lemma}
\begin{proof}
  By the definition of similarity and \Cref{corollary:inj-sort}.
\end{proof}

\begin{lemma}[Type Similarity]\label[lemma]{lemma:type-similarity}
  Given $\Gamma_1 \vdash m : A$ and $\Gamma_2 \vdash m : B$ and $\Sim{\Gamma_1}{\Gamma_2}$,
  then $\Sim{A}{B}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\Gamma_1 \vdash m : A$.
\end{proof}

\begin{theorem}[Sort Uniqueness]\label[theorem]{theorem:sort-uniqueness}
  Given $\Gamma \vdash m : s$ and $\Gamma \vdash m : t$, then $s = t$.
\end{theorem}
\begin{proof}
  From \Cref{lemma:headsim-reflexive} we have $\Sim{\Gamma}{\Gamma}$.
  Then from \Cref{lemma:type-similarity} we have $\Sim{s}{t}$.
  Finally from \Cref{lemma:sim-sort-injective} we have $s = t$.
\end{proof}

\paragraph{\textbf{Inversion}}
Due to the presence of type conversion, inversion lemmas are necessary to reason about
typing derivations.

\begin{lemma}\label[lemma]{lemma:logical-inversion-explicit-fun}
  If $\Gamma \vdash \PiR{s}{x : A}{B} : C$, then there exists $t$
  such that $\Gamma, x : A \vdash B : t$ and $C \simeq s$.
\end{lemma}

\begin{lemma}\label[lemma]{lemma:logical-inversion-implicit-fun}
  If $\Gamma \vdash \PiI{s}{x : A}{B} : C$, then there exists $t$
  such that $\Gamma, x : A \vdash B : t$ and $C \simeq s$.
\end{lemma}

\begin{lemma}\label[lemma]{lemma:logical-inversion-explicit-lam}
  If $\Gamma \vdash \lamR{s_1}{x : A_1}{m} : \PiR{s_2}{x : A_2}{B}$, then $\Gamma, x : A_1 \vdash m : B$.
\end{lemma}

\begin{lemma}\label[lemma]{lemma:logical-inversion-implicit-lam}
  If $\Gamma \vdash \lamI{s_1}{x : A_1}{m} : \PiI{s_2}{x : A_2}{B}$, then $\Gamma, x : A_1 \vdash m : B$.
\end{lemma}

\begin{lemma}\label[lemma]{lemma:logical-inversion-explicit-sig}
  If $\Gamma \vdash \SigR{t}{x : A}{B} : C$, then there exists $s, r$ such that
  $s \sqsubseteq t$ and $r \sqsubseteq t$ and
  $\Gamma \vdash A : s$ and $\Gamma, x : A \vdash B : r$ and $C \simeq t$.
\end{lemma}

\begin{lemma}\label[lemma]{lemma:logical-inversion-implicit-sig}
  If $\Gamma \vdash \SigI{t}{x : A}{B} : C$, then there exists $s, r$ such that
  $r \sqsubseteq t$ and
  $\Gamma \vdash A : s$ and $\Gamma, x : A \vdash B : r$ and $C \simeq t$.
\end{lemma}

\begin{lemma}\label[lemma]{lemma:logical-inversion-monad}
  If $\Gamma \vdash \CM{A} : B$, then there exists $s$ such that $\Gamma \vdash A : s$ and $B \simeq \Ln$.
\end{lemma}

\begin{lemma}\label[lemma]{lemma:logical-inversion-ch}
  If $\Gamma \vdash \CH{A} : B$, then $\Gamma \vdash A : \Proto$ and $B \simeq \Ln$. 
\end{lemma}

\begin{lemma}\label[lemma]{lemma:logical-inversion-hc}
  If $\Gamma \vdash \HC{A} : B$, then $\Gamma \vdash A : \Proto$ and $B \simeq \Ln$. 
\end{lemma}

\begin{lemma}\label[lemma]{lemma:logical-inversion-explicit-action}
  If $\Gamma \vdash \ActR{\rho}{x : A}{B} : C$, then $\Gamma, x : A \vdash B : \Proto$.
\end{lemma}

\begin{lemma}\label[lemma]{lemma:logical-inversion-implicit-action}
  If $\Gamma \vdash \ActI{\rho}{x : A}{B} : C$, then $\Gamma, x : A \vdash B : \Proto$.
\end{lemma}

\begin{lemma}\label[lemma]{lemma:program-inversion-explicit-lam}
  If ${\Theta ; \Gamma ; \Delta \vdash \lamR{s}{x : A_2}{m} : \PiR{t}{x : A_1}{B}}$, then
  ${\Theta ; \Gamma, x : A_1 ; \Delta, x :_r A_1 \vdash m : B}$.
\end{lemma}

\begin{lemma}\label[lemma]{lemma:program-inversion-explicit-pair}
  If ${\Theta ; \Gamma ; \Delta \vdash \pairR{m}{n}{s} : \SigR{t}{x : A}{B}}$, then
  there exists $\Theta_1, \Theta_2, \Delta_1, \Delta_2$ such that
  ${\Theta_1 ; \Gamma ; \Delta_1 \vdash m : A}$ and
  ${\Theta_2 ; \Gamma ; \Delta_2 \vdash n : B[m/x]}$ and
  $\Theta = \Theta_1 \dotcup \Theta_2$ and $\Delta = \Delta_1 \dotcup \Delta_2$ and
  $s = t$.
\end{lemma}

\begin{lemma}\label[lemma]{lemma:program-inversion-unit}
  If ${\Theta ; \Gamma ; \Delta \vdash \ii : \unit}$, then
  $\Theta = \epsilon$ and $\Delta \triangleright \Un$.
\end{lemma}

\begin{lemma}\label[lemma]{lemma:program-inversion-true}
  If ${\Theta ; \Gamma ; \Delta \vdash \bTrue : \Bool}$, then
  $\Theta = \epsilon$ and $\Delta \triangleright \Un$.
\end{lemma}

\begin{lemma}\label[lemma]{lemma:program-inversion-false}
  If ${\Theta ; \Gamma ; \Delta \vdash \bFalse : \Bool}$, then
  $\Theta = \epsilon$ and $\Delta \triangleright \Un$.
\end{lemma}

\begin{lemma}\label[lemma]{lemma:program-inversion-return}
  If ${\Theta ; \Gamma ; \Delta \vdash \return{m} : \CM{A}}$, then
  ${\Theta ; \Gamma ; \Delta \vdash m : A}$.
\end{lemma}

\paragraph{\textbf{Type Validity}}
We show that all types appearing in typing judgments are valid, i.e. they are well-sorted
at the logical level.

\begin{theorem}[Logical Type Validity]\label[theorem]{theorem:logical-type-validity}
  If $\Gamma \vdash m : A$, then there exists $s$ such that $\Gamma \vdash A : s$.
\end{theorem}
\begin{proof}
  By induction on the derivation of $\Gamma \vdash m : A$. We will show some representative cases.

\textbf{Case} (\textsc{Var}): 
  From the premise we have $\Gamma, x : A \vdash$ which implies $\Gamma \vdash A : s$ for some $s$.

\textbf{Case} (\textsc{Explicit-Lam}):
  From the induction hypothesis we have $\Gamma, x : A \vdash B : r$ for some $r$.
  The validity of context $\Gamma, x : A \vdash$ implies $\Gamma \vdash A : s$ for some $s$.
  Then from \textsc{Explicit-Fun} we have $\Gamma \vdash \PiR{s}{x : A}{B} : s$ which concludes this case.

\textbf{Case} (\textsc{Explicit-App}):
  From the induction hypothesis we have $\Gamma \vdash \PiR{s}{x : A}{B} : r$ for some $r$.
  From \Cref{lemma:logical-inversion-explicit-fun} we have $\Gamma, x : A \vdash B : t$ for some $t$.
  By \Cref{lemma:logical-subst} we have $\Gamma \vdash B[n/x] : t$ which concludes this case.

\textbf{Case} (\textsc{Explicit-Recv-CH}):
  From the induction hypothesis we have $\Gamma \vdash \CH{\ActR{?}{x : A}{B}} : s$ for some $s$.
  By \Cref{lemma:logical-inversion-ch} we have $\Gamma \vdash \ActR{?}{x : A}{B} : \Proto$.
  By \Cref{lemma:logical-inversion-explicit-action} we have $\Gamma, x : A \vdash B : \Proto$.
  From the validity of context $\Gamma, x : A \vdash$ we have $\Gamma \vdash A : t$ for some $t$.
  Applying \textsc{ChType}, we have $\Gamma, x : A \vdash \CH{B} : \Ln$.
  Applying \textsc{Explicit-Sum}, we have $\Gamma \vdash \SigR{\Ln}{x : A}{\CH{B}} : \Ln$.
  Applying \textsc{$\mcC$Type}, we have $\Gamma \vdash \CM{\SigR{\Ln}{x : A}{\CH{B}}} : \Ln$ which concludes this case.
\end{proof}

To show that the types appearing in program level typing judgments are valid, 
we first prove the lifting theorem which allows us to lift programs to the logical level.

\begin{theorem}[Lifting]\label[theorem]{theorem:lifting}
  If $\Theta ; \Gamma ; \Delta \vdash m : A$, then $\Gamma \vdash m : A$.
\end{theorem}
\begin{proof}
  By induction on the derivation of $\Theta ; \Gamma ; \Delta \vdash m : A$.
\end{proof}

\begin{theorem}[Program Type Validity]\label[theorem]{theorem:program-type-validity}
  If $\Theta ; \Gamma ; \Delta \vdash m : A$, then there exists $s$ such that $\Gamma \vdash A : s$.
\end{theorem}
\begin{proof}
  Immediate from \Cref{theorem:lifting} and \Cref{theorem:logical-type-validity}.
\end{proof}

\paragraph{\textbf{Subject Reduction}}
We show that both the logical and program level type systems enjoy subject reduction
under logical and program reductions respectively.

\begin{lemma}[Arity Preservation]\label[lemma]{lemma:arity-preservation}
  If $A \Rightarrow A'$ and $A~\arity{\Proto}$, then $A'~\arity{\Proto}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $A \Rightarrow A'$.
\end{proof}

\begin{lemma}[Guard Preservation]\label[lemma]{lemma:guard-preservation}
  If $A \Rightarrow A'$ and $A~\guard{x}$, then $A'~\guard{x}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $A \Rightarrow A'$ and appealing to  
  \Cref{lemma:subst-guard}.
\end{proof}

\begin{theorem}[Logical Subject Reduction]\label[theorem]{theorem:logical-subject-reduction}
  If $\Gamma \vdash m : A$ and $m \Rightarrow m'$, then $\Gamma \vdash m' : A$.
\end{theorem}
\begin{proof}
  By induction on the derivation of $\Gamma \vdash m : A$ and case analysis on the reduction $m \Rightarrow m'$.
  We present the following representative cases.

\textbf{Case} (\textsc{Explicit-Lam}):
  From case analysis on the reduction, we have $A \Rightarrow A'$ and $m \Rightarrow m'$.
  From the induction hypothesis we have $\Gamma, x : A \vdash m' : B$ and $\Gamma \vdash A' : s$ for some $s$.
  By definition of convertibility, we have $A \simeq A'$.
  By \Cref{corollary:logical-context-conv} we have $\Gamma, x : A' \vdash m' : B$.
  By \textsc{Explicit-Lam} we have $\Gamma \vdash \lamR{s}{x : A'}{m'} : \PiR{s}{x : A'}{B}$.
  By \textsc{Conversion} we have $\Gamma \vdash \lamR{s}{x : A'}{m'} : \PiR{s}{x : A}{B}$ which concludes this case.

\textbf{Case} (\textsc{Explicit-App}):
  From case analysis on the reduction we have two sub-cases:
  (1) \textsc{PStep-Explicit-App} and (2) \textsc{PStep-Explicit-$\beta$}.

  In sub-case (1) \textsc{PStep-Explicit-App}, we have $m \Rightarrow m'$ and $n \Rightarrow n'$.
  From the induction hypothesis we have $\Gamma \vdash m' : \PiR{s}{x : A}{B}$ and $\Gamma \vdash n' : A$.
  By \textsc{Explicit-App} we have $\Gamma \vdash \appR{m'}{n'} : B[n'/x]$.
  By definition of convertibility, we have $B[n/x] \simeq B[n'/x]$.
  By validity we have $\Gamma \vdash \PiR{s}{x : A}{B} : t$ for some $t$.
  By \Cref{lemma:logical-inversion-explicit-fun} we have $\Gamma, x : A \vdash B : r$ for some $r$.
  By \Cref{lemma:logical-subst} we have $\Gamma \vdash B[n/x] : r$.
  By \textsc{Conversion} we have $\Gamma \vdash \appR{m'}{n'} : B[n/x]$ which concludes this sub-case.

  In sub-case (2) \textsc{PStep-Explicit-$\beta$}, we have $m = \lamR{s}{x : A}{m_0}$ for some $m_0$
  and $m_0 \Rightarrow m_0'$ and $n \Rightarrow n'$.
  By \Cref{lemma:logical-inversion-explicit-lam} we have $\Gamma, x : A \vdash m_0 : B$.
  By the induction hypothesis we have $\Gamma, x : A \vdash m_0' : B$ and $\Gamma \vdash n' : A$.
  By \Cref{lemma:logical-subst} we have $\Gamma \vdash m_0'[n'/x] : B[n'/x]$.
  By definition of convertibility, we have $B[n/x] \simeq B[n'/x]$
  By validity we have $\Gamma \vdash \PiR{s}{x : A}{B} : t$ for some $t$.
  By \Cref{lemma:logical-inversion-explicit-fun} we have $\Gamma, x : A \vdash B : r$ for some $r$.
  By \Cref{lemma:logical-subst} we have $\Gamma \vdash B[n/x] : r$.
  By \textsc{Conversion} we have $\Gamma \vdash m_0'[n'/x] : B[n/x]$ which concludes this sub-case.

\textbf{Case} (\textsc{BoolElim})
  From case analysis on the reduction we have three sub-cases:
  (1) \textsc{PStep-BoolElim}, (2) \textsc{PStep-TrueElim}, and (3) \textsc{PStep-FalseElim}.

  In sub-case (1) \textsc{PStep-BoolElim}, we have 
  $A \Rightarrow A'$, $m \Rightarrow m'$, $n_1 \Rightarrow n_1'$, and $n_2 \Rightarrow n_2'$.
  By the induction hypothesis we have
  $\Gamma, z : \Bool \vdash A' : s$, 
  $\Gamma \vdash m' : \Bool$, 
  $\Gamma \vdash n_1' : A[\bTrue/z]$, and 
  $\Gamma \vdash n_2' : A[\bFalse/z]$.
  By definition of convertibility, we have $A \simeq A'$.
  By \Cref{lemma:logical-subst} we have $\Gamma \vdash A'[\bTrue/z] : s$ and $\Gamma \vdash A'[\bFalse/z] : s$.
  By \textsc{Conversion} we have $\Gamma \vdash n_1' : A'[\bTrue/z]$ and $\Gamma \vdash n_2' : A'[\bFalse/z]$.
  By \textsc{BoolElim} we have $\Gamma \vdash \boolElim{[z]A'}{m'}{n_1'}{n_2'} : A'[m'/z]$.
  By definition of convertibility, we have $A[m/z] \simeq A'[m'/z]$.
  By \Cref{lemma:logical-subst} we have $\Gamma \vdash A[m/z] : s$.
  By \textsc{Conversion} we have $\Gamma \vdash \boolElim{[z]A'}{m'}{n_1'}{n_2'} : A[m/z]$ which concludes this sub-case.

\textbf{Case} (\textsc{RecProto}):
  From case analysis on the reduction we have two sub-cases:
  (1) \textsc{PStep-RecProto} and (2) \textsc{PStep-RecUnfold}.

  In sub-case (1) \textsc{PStep-RecProto}, we have $A \Rightarrow A'$ and $m \Rightarrow m'$.
  By validity of context $\Gamma, x : A \vdash$ we have $\Gamma \vdash A : s$ for some $s$.
  By the induction hypothesis we have ${\Gamma, x : A \vdash m' : A}$ and ${\Gamma \vdash A' : s}$.
  By definition of convertibility, we have $A \simeq A'$.
  By \Cref{corollary:logical-context-conv} we have $\Gamma, x : A' \vdash m' : A$.
  By \textsc{Conversion} we have $\Gamma, x : A' \vdash m' : A'$.
  By \Cref{lemma:arity-preservation} we have $A'~\arity{\Proto}$.
  By \Cref{lemma:guard-preservation} we have $m'~\guard{x}$.
  By \textsc{RecProto} we have $\Gamma \vdash \fix{x : A'}{m'} : A'$.
  By \textsc{Conversion} we have $\Gamma \vdash \fix{x : A'}{m'} : A$ which concludes this sub-case.

  In sub-case (2) \textsc{PStep-RecUnfold}, we have $A \Rightarrow A'$ and $m \Rightarrow m'$.
  By validity of context $\Gamma, x : A \vdash$ we have $\Gamma \vdash A : s$ for some $s$.
  By the induction hypothesis we have ${\Gamma, x : A \vdash m' : A}$ and ${\Gamma \vdash A' : s}$.
  By definition of convertibility, we have $A \simeq A'$.
  By \Cref{corollary:logical-context-conv} we have $\Gamma, x : A' \vdash m' : A$.
  By \textsc{Conversion} we have $\Gamma, x : A' \vdash m' : A'$.
  By \Cref{lemma:arity-preservation} we have $A'~\arity{\Proto}$.
  By \Cref{lemma:guard-preservation} we have $m'~\guard{x}$.
  By \textsc{RecProto} we have $\Gamma \vdash \fix{x : A'}{m'} : A'$.
  By \Cref{lemma:logical-subst} we have $\Gamma \vdash m'[\fix{x : A'}{m'}/x] : A'$.
  By \textsc{Conversion} we have $\Gamma \vdash m'[\fix{x : A'}{m'}/x] : A$ which concludes this sub-case.
\end{proof}

In order to show subject reduction at the program level, we need to show that reduction of
redexes in dependent positions preserves typing. To do so, we prove the following lemma which
lifts program reductions into convertibility at the logical level.
\begin{lemma}[Program Step Convertible]\label[lemma]{lemma:program-step-convertible}
  If ${\Theta ; \epsilon ; \epsilon \vdash m : A}$ and $m \Leadsto n$, then $m \simeq n$.
\end{lemma}

The program level substitution lemma (\Cref{lemma:program-subst-explicit})
requires context restrictions $\Theta_2 \triangleright s$ and $\Delta_2 \triangleright s$ for the
substituted term $n$. To ensure that these restrictions are satisfied for \emph{values}, we prove the
following context bound lemma.
\begin{lemma}[Program Context Bound]\label[lemma]{lemma:program-context-bound}
  Given ${\Theta ; \Gamma ; \Delta \vdash v : A}$ and $\Gamma \vdash A : s$, then 
  $\Theta \triangleright s$ and $\Delta \triangleright s$.
\end{lemma}
\begin{proof}
  By induction on the derivation of ${\Theta ; \Gamma ; \Delta \vdash v : A}$ where $v$ is a value.
  We present the following representative cases.

\textbf{Case} (\textsc{Explicit-Lam}):
  From the premise we have $\Theta \triangleright t$ and $\Delta \triangleright t$.
  By \Cref{lemma:logical-inversion-explicit-fun} we have $t \simeq s$.
  By injectivity of sorts (\Cref{corollary:inj-sort}) we have $t = s$ which concludes this case.

\textbf{Case} (\textsc{Explicit-Pair}):
  From the assumption that the pair is a value, we have $v = \pairR{v_1}{v_2}{t}$ for some $t$.
  Additionally, we have $\Theta_1 ; \Gamma ; \Delta_1 \vdash v_1 : A$ and 
  $\Theta_2 ; \Gamma ; \Delta_2 \vdash v_2 : B[v_1/x]$ and $\Gamma \vdash \SigR{t}{x : A}{B} : t$.
  By \Cref{theorem:sort-uniqueness} we have $s = t$.
  By \Cref{lemma:logical-inversion-explicit-sig} we have 
  $\Gamma \vdash A : s$ and $\Gamma, x : A \vdash B : r$ and $s \sqsubseteq t$ and $r \sqsubseteq t$.
  By the induction hypothesis we have $\Theta_1 \triangleright s$ and $\Delta_1 \triangleright s$
  and $\Theta_2 \triangleright r$ and $\Delta_2 \triangleright r$.
  These context restrictions can then be weakened to $\Theta_1 \triangleright t$ and $\Delta_1 \triangleright t$ 
  and $\Theta_2 \triangleright t$ and $\Delta_2 \triangleright t$.
  The merged contexts now satisfy $\Theta_1 \dotcup \Theta_2 \triangleright t$ and 
  $\Delta_1 \dotcup \Delta_2 \triangleright t$ which concludes this case.

\textbf{Case} (\textsc{Return}):
  From the premise we have $\Theta ; \Gamma ; \Delta \vdash m : A$ and $\Gamma \vdash \CM{A} : s$.
  By \Cref{theorem:sort-uniqueness} we have $s = \Ln$. 
  The context restrictions $\Theta \triangleright \Ln$ and $\Delta \triangleright \Ln$ hold trivially which concludes this case.

\textbf{Case} (\textsc{Channel-CH})
  From the premise we have $\Theta \triangleright \Un$. From \textsc{Ord-$\Un$} we have $\Un \sqsubseteq s$
  which allows us to weaken the restriction into $\Theta \triangleright s$ and concluding this case.

\textbf{Case} (\textsc{Explicit-Send-CH}):
  From the premise we have $\Gamma \vdash \PiR{\Ln}{x : A}{\CM{\CH{B}}} : s$. 
  By \Cref{theorem:sort-uniqueness} we have $s = \Ln$.
  The context restrictions $\Theta \triangleright \Ln$ and $\Delta \triangleright \Ln$ hold trivially.
\end{proof}

\begin{theorem}[Program Subject Reduction]\label[theorem]{theorem:program-subject-reduction}
  If ${\Theta ; \epsilon ; \epsilon \vdash m : A}$ and ${m \Leadsto m'}$, then ${\Theta ; \epsilon ; \epsilon \vdash m' : A}$.
\end{theorem}
\begin{proof}
  By induction on the derivation of ${\Theta ; \epsilon ; \epsilon \vdash m : A}$ and case 
  analysis on the reduction $m \Leadsto m'$. We present the following representative cases.

\textbf{Case} (\textsc{Explicit-App}):
  From case analysis on the reduction we have three sub-cases:
  (1) \textsc{Step-Explicit-App$_1$}, (2) \textsc{Step-Explicit-App$_2$}, and (3) \textsc{Step-Explicit-$\beta$}.

  In sub-case (1) \textsc{Step-Explicit-App$_1$}, we have $m \Leadsto m'$.
  By the induction hypothesis we have ${\Theta_1 ; \Gamma ; \Delta_1 \vdash m' : \PiR{t}{x : A}{B}}$.
  By \textsc{Explicit-App} we have ${\Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash \appR{m'}{n} : B[n/x]}$
  which concludes this sub-case.

  In sub-case (2) \textsc{Step-Explicit-App$_2$}, we have $n \Leadsto n'$.
  By the induction hypothesis we have ${\Theta_2 ; \Gamma ; \Delta_2 \vdash n' : A}$.
  By \textsc{Explicit-App} we have ${\Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash \appR{m}{n'} : B[n'/x]}$.
  By \Cref{lemma:program-step-convertible} we have $n \simeq n'$ and $B[n/x] \simeq B[n'/x]$.
  By \Cref{theorem:lifting} we have $\Gamma \vdash n : A$.
  Applying \Cref{theorem:program-type-validity} on $\Theta_1; \Gamma ; \Delta_1 \vdash m : \PiR{t}{x : A}{B}$ we have
  $\Gamma \vdash \PiR{t}{x : A}{B} : s$ for some $s$.
  By \Cref{lemma:logical-inversion-explicit-fun} we have $\Gamma, x : A \vdash B : r$ for some $r$.
  By \Cref{lemma:logical-subst} we have $\Gamma \vdash B[n/x] : r$.
  By \textsc{Conversion} we have ${\Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash \appR{m}{n'} : B[n/x]}$
  which concludes this sub-case.

  In sub-case (3) \textsc{Step-Explicit-$\beta$}, we have $m = \lamR{t}{x : A_0}{m_0}$ for some $A_0$ and $m_0$.
  By \Cref{lemma:program-inversion-explicit-lam} we have ${\Theta_1 ; \Gamma, x : A ; \Delta_1, x :_r A \vdash m_0 : B}$.
  From the validity of context ${\Theta_1 ; \Gamma, x : A ; \Delta_1, x :_r A \vdash}$ we have $\Gamma \vdash A : r$.
  By \Cref{lemma:program-context-bound} and ${\Theta_2 ; \Gamma ; \Delta_2 \vdash v : A}$ and $\Gamma \vdash A : r$
  we have $\Theta_2 \triangleright r$.
  By \Cref{lemma:program-subst-explicit} we have 
  ${\Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash m_0[v/x] : B[v/x]}$ 
  which concludes this sub-case.

\textbf{Case} (\textsc{Explicit-SumElim}):
  From case analysis on the reduction we have two sub-cases:
  (1) \textsc{Step-SumElim$_1$} and (2) \textsc{Step-Explicit-PairElim}.

  In sub-case (1) \textsc{Step-SumElim$_1$}, we have $m \Leadsto m'$.
  By the induction hypothesis we have ${\Theta_1 ; \Gamma ; \Delta_1 \vdash m' : \SigR{t}{x : A}{B}}$
  By \textsc{Explicit-SumElim} we have
  ${\Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash \SigElim{[z]C}{m'}{[x,y]n} : C[m'/z]}$.
  By \Cref{lemma:program-step-convertible} we have $m \simeq m'$ and $C[m/z] \simeq C[m'/z]$.
  By \Cref{theorem:lifting} we have $\Gamma \vdash m : \SigR{t}{x : A}{B}$.
  Applying \Cref{lemma:logical-subst} on assumption $\Gamma, z : \SigR{t}{x : A}{B} \vdash C : s$ and
  $\Gamma \vdash m : \SigR{t}{x : A}{B}$ we have $\Gamma \vdash C[m/z] : s$. By \textsc{Conversion} we have 
  ${\Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash \SigElim{[z]C}{m'}{[x,y]n} : C[m/z]}$
  which concludes this sub-case.

  In sub-case (2) \textsc{Step-Explicit-PairElim}, we have $m = \pairR{u}{v}{t}$ for some $u, v$ and $t$.
  By \Cref{lemma:program-inversion-explicit-pair} we have
  ${\Theta_{11} ; \Gamma ; \Delta_{11} \vdash u : A}$ and
  ${\Theta_{12} ; \Gamma ; \Delta_{12} \vdash v : B[u/x]}$ and
  $\Theta_1 = \Theta_{11} \dotcup \Theta_{12}$ and $\Delta_1 = \Delta_{11} \dotcup \Delta_{12}$ and $s = t$.
  From the validity of context $\Theta_2 ; \Gamma, x : A, y : B ; \Delta_2, x :_{r_1} A, y :_{r_2} B \vdash$
  we have $\Gamma \vdash A : r_1$ and $\Gamma, x : A \vdash B : r_2$.
  Applying \Cref{theorem:lifting} to ${\Theta_{11} ; \Gamma ; \Delta_{11} \vdash u : A}$ we have
  $\Gamma \vdash u : A$. Applying \Cref{lemma:logical-subst} we have $\Gamma \vdash B[u/x] : r_2$.
  By \Cref{lemma:program-context-bound} and ${\Theta_{11} ; \Gamma ; \Delta_{11} \vdash u : A}$ and $\Gamma \vdash A : r_1$
  we have $\Theta_{11} \triangleright r_1$.
  By \Cref{lemma:program-context-bound} and ${\Theta_{12} ; \Gamma ; \Delta_{12} \vdash v : B[u/x]}$ and $\Gamma \vdash B[u/x] : r_2$
  we have $\Theta_{12} \triangleright r_2$.
  By \Cref{lemma:program-subst-explicit} we have
  ${\Theta_{11} \dotcup \Theta_{12} \dotcup \Theta_2 ; \Gamma ; \Delta_{11} \dotcup \Delta_{12} \dotcup \Delta_2 \vdash n[u/x, v/y] : C[\pairR{u}{v}{t}/z]}$
  which concludes this sub-case.

\textbf{Case} (\textsc{BoolElim}):
  By case analysis on the reduction we have three sub-cases:
  (1) \textsc{Step-BoolElim$_1$}, (2) \textsc{Step-TrueElim}, and (3) \textsc{Step-FalseElim}.

  In sub-case (1) \textsc{Step-BoolElim$_1$}, we have $m \Leadsto m'$.
  By the induction hypothesis we have ${\Theta_1 ; \Gamma ; \Delta_1 \vdash m' : \Bool}$.
  By \textsc{BoolElim} we have
  ${\Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash \boolElim{[z]C}{m'}{n_1}{n_2} : C[m'/z]}$.
  By \Cref{lemma:program-step-convertible} we have $m \simeq m'$ and $C[m/z] \simeq C[m'/z]$.
  By \Cref{theorem:lifting} we have $\Gamma \vdash m : \Bool$.
  Applying \Cref{lemma:logical-subst} on ${\Gamma, z : \Bool \vdash C : s}$ and
  ${\Gamma \vdash m : \Bool}$ we have ${\Gamma \vdash C[m/z] : s}$.
  By \textsc{Conversion} we have
  ${\Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash \boolElim{[z]C}{m'}{n_1}{n_2} : C[m/z]}$
  which concludes this sub-case.

  In sub-case (2) \textsc{Step-TrueElim}, we have $m = \bTrue$.
  By \Cref{lemma:program-inversion-true} we have $\Theta_1 = \epsilon$ and $\Delta_1 \triangleright \Un$.
  Thus we have $\Theta_1 \dotcup \Theta_2 = \Theta_2$ and $\Delta_1 \dotcup \Delta_2 = \Delta_2$.
  The assumption $\Theta_2 ; \Gamma ; \Delta_2 \vdash n_1 : C[\bTrue/z]$ gives us the desired result
  which concludes this sub-case.

  In sub-case (3) \textsc{Step-FalseElim}, we have $m = \bFalse$.
  By \Cref{lemma:program-inversion-false} we have $\Theta_1 = \epsilon$ and $\Delta_1 \triangleright \Un$.
  Thus we have $\Theta_1 \dotcup \Theta_2 = \Theta_2$ and $\Delta_1 \dotcup \Delta_2 = \Delta_2$.
  The assumption $\Theta_2 ; \Gamma ; \Delta_2 \vdash n_2 : C[\bFalse/z]$ gives us the desired result
  which concludes this sub-case.

\textbf{Case} (\textsc{Bind}):
  By case analysis on the reduction we have two sub-cases: 
  (1) \textsc{Step-Bind} and (2) \textsc{Step-ReturnBind}.

  In sub-case (1) \textsc{Step-Bind}, we have $m \Leadsto m'$.
  By the induction hypothesis we have ${\Theta_1 ; \Gamma ; \Delta_1 \vdash m' : \CM{A}}$.
  By \textsc{Bind} we have ${\Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash \letin{x}{m'}{n} : C}$ 
  which concludes this sub-case.

  In sub-case (2) \textsc{Step-ReturnBind}, we have $m = \return{v}$ for some value $v$.
  By \Cref{lemma:program-inversion-return} we have ${\Theta_1 ; \Gamma ; \Delta_1 \vdash v : A}$.
  From the validity of context ${\Theta_2 ; \Gamma, x : A ; \Delta_2, x :_r A \vdash}$ we have $\Gamma \vdash A : r$.
  By \Cref{lemma:program-context-bound} and ${\Theta_1 ; \Gamma ; \Delta_1 \vdash v : A}$ and $\Gamma \vdash A : r$
  we have $\Theta_1 \triangleright r$.
  By \Cref{lemma:program-subst-explicit} we have
  ${\Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash n[v/x] : \CM{B[v/x]}}$.
  From assumption $\Gamma \vdash B : s$ we know that $x \notin \FV{B}$, thus $B[v/x] = B$
  and ${\Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash n[v/x] : \CM{B}}$.
  which concludes this sub-case.
\end{proof}

\paragraph{\textbf{Progress}}
Due to the presence of concurrency primitives, the values that the program level
terms can reduce to are not necessarily canonical forms. They can also be thunked monadic computations.
These thunked computations will eventually be reduced by the semantics of the process level.

The following canonical forms lemmas are used to prove program progress (\Cref{theorem:program-progress}). 
They are proved by induction on the typing derivation of the value.
\begin{lemma}\label[lemma]{lemma:program-explicit-fun-canonical}
  If ${\Theta ; \epsilon ; \epsilon \vdash v : \PiR{s}{x : A}{B}}$ then
  $v = \lamR{s}{x : A}{m}$ or $v = \sendR{u}$.
\end{lemma}

\begin{lemma}\label[lemma]{lemma:program-implicit-fun-canonical}
  If ${\Theta ; \epsilon ; \epsilon \vdash v : \PiI{s}{x : A}{B}}$ then
  $v = \lamI{s}{x : A}{m}$ or $v = \sendI{u}$.
\end{lemma}

\begin{lemma}\label[lemma]{lemma:program-sig-canonical}
  If ${\Theta ; \epsilon ; \epsilon \vdash v : \SigR{s}{x : A}{B}}$ then
  $v = \pairR{v_1}{v_2}{s}$.
\end{lemma}

\begin{lemma}\label[lemma]{lemma:program-implicit-sig-canonical}
  If ${\Theta ; \epsilon ; \epsilon \vdash v : \SigI{s}{x : A}{B}}$ then
  $v = \pairI{m}{v_2}{s}$.
\end{lemma}

\begin{lemma}\label[lemma]{lemma:program-bool-canonical}
  If ${\Theta ; \epsilon ; \epsilon \vdash v : \Bool}$ then
  $v = \bTrue$ or $v = \bFalse$.
\end{lemma}

\begin{theorem}[Program Progress]\label[theorem]{theorem:program-progress}
  If ${\Theta ; \epsilon ; \epsilon \vdash m : A}$, then $m$ is a value or there exists $m'$ such that $m \Leadsto m'$.
\end{theorem}
\begin{proof}
  By induction on the derivation of ${\Theta ; \epsilon ; \epsilon \vdash m : A}$.
  We present the following cases.

\textbf{Case} (\textsc{Var}): Impossible since the context is empty.

\textbf{Case} (\textsc{Explicit-Lam}): Trivial since $\lamR{t}{x : A}{m_0}$ is a value.

\textbf{Case} (\textsc{Explicit-App}):
  By the induction hypothesis we have that either $m$ is a value or there exists $m'$ such that $m \Leadsto m'$.
  If $m \Leadsto m'$, then we are done by \textsc{Step-Explicit-App$_1$}.
  If $m$ is a value, by \Cref{lemma:program-explicit-fun-canonical} we have two sub-cases:
  (1) $m = \lamR{t}{x : A}{m_0}$ and (2) $m = \sendR{u}$.

  In sub-case (1) $m = \lamR{t}{x : A}{m_0}$, by the induction hypothesis on $n$ we have
  that either $n$ is a value or there exists $n'$ such that $n \Leadsto n'$.
  If $n \Leadsto n'$, then we are done by \textsc{Step-Explicit-App$_2$}.
  If $n$ is a value, then we are done by \textsc{Step-Explicit-$\beta$}.

  In sub-case (2) $m = \sendR{u}$, by the induction hypothesis on $n$ we have
  that either $n$ is a value or there exists $n'$ such that $n \Leadsto n'$.
  If $n \Leadsto n'$, then we are done by \textsc{Step-Explicit-App$_2$}.
  If $n$ is a value $v$, then we are done as $\sendR{u}\ v$ is a value.

\textbf{Case} (\textsc{Explicit-Pair}):
  By assumption we have 
  ${\Theta_1 ; \Gamma ; \Delta_1 \vdash m_1 : A}$ and 
  ${\Theta_2 ; \Gamma ; \Delta_2 \vdash m_2 : B[m_1/x]}$.
  From the induction hypothesis we have that either $m_1$ is a value or there exists $m_1'$ such that $m_1 \Leadsto m_1'$.
  If $m_1 \Leadsto m_1'$, then we are done by \textsc{Step-Explicit-Pair$_1$}.
  If $m_1$ is a value $u$, then by the induction hypothesis on $m_2$ we have
  that either $m_2$ is a value or there exists $m_2'$ such that $m_2 \Leadsto m_2'$.
  If $m_2 \Leadsto m_2'$, then we are done by \textsc{Step-Explicit-Pair$_2$}.
  If $m_2$ is a value $v$, then we are done since $\pairR{u}{v}{t}$ is a value.

\textbf{Case} (\textsc{Explicit-SumElim}):
  By the induction hypothesis we have that either $m$ is a value or there exists $m'$ such that $m \Leadsto m'$.
  If $m \Leadsto m'$, then we are done by \textsc{Step-SumElim$_1$}.
  If $m$ is a value, by \Cref{lemma:program-sig-canonical} we have $m = \pairR{u}{v}{t}$ for some $u, v$ and $t$.
  We are done by \textsc{Step-Explicit-PairElim}.

\textbf{Case} (\textsc{BoolElim}):
  By the induction hypothesis we have that either $m$ is a value or there exists $m'$ such that $m \Leadsto m'$.
  If $m \Leadsto m'$, then we are done by \textsc{Step-BoolElim$_1$}.
  If $m$ is a value, by \Cref{lemma:program-bool-canonical} we have two sub-cases:
  (1) $m = \bTrue$ and (2) $m = \bFalse$.
  In sub-case (1) $m = \bTrue$, we are done by \textsc{Step-TrueElim}.
  In sub-case (2) $m = \bFalse$, we are done by \textsc{Step-FalseElim}.

\textbf{Case} (\textsc{Return}):
  By the induction hypothesis we have that either $m$ is a value or there exists $m'$ such that $m \Leadsto m'$.
  If $m \Leadsto m'$, then we are done by \textsc{Step-Return}.
  If $m$ is a value, then $\return{m}$ is a value.

\textbf{Case} (\textsc{Bind}):
  By the induction hypothesis we have that either $m$ is a value or there exists $m'$ such that $m \Leadsto m'$.
  If $m \Leadsto m'$, then we are done by \textsc{Step-Bind}.
  If $m$ is a value, then $\letin{x}{m}{n}$ is a value.

For the session typing rules, the term $m$ is a thunked computation and thus a value.
\end{proof}