To show that the \TLLC{} extensions made are compatible with the theory of TLL,
we prove the \TLLC{} terms enjoy the same properties as TLL ones. 

\paragraph{\textbf{Confluence}}
We show that the logical reduction relation is confluent. 
This property is important as it ensures that type convertibility can be checked
regardless of the order in which reductions are applied. 
Confluence is easy to prove here as the parallel reduction satisfies the diamond property.

\begin{lemma}[Diamond Property]\label[lemma]{lemma:diamond}
  If $m \Rightarrow m_1$ and $m \Rightarrow m_2$, then there exists $m'$ such that
  $m_1 \Rightarrow m'$ and $m_2 \Rightarrow m'$.
\end{lemma}
\begin{proof}
  By induction on the structure of the parallel reduction.
\end{proof}

\begin{lemma}\label[lemma]{lemma:strip}
  If $m \Rightarrow m_1$ and $m \Rightarrow^* m_2$, then there exists $m'$ such that
  $m_1 \Rightarrow^* m'$ and $m_2 \Rightarrow m'$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $m \Rightarrow^* m_2$ and \Cref{lemma:diamond}.
\end{proof}

\begin{theorem}[Confluence]
  If $m \Rightarrow^* m_1$ and $m \Rightarrow^* m_2$, then there exists $m'$ such that
  $m_1 \Rightarrow^* m'$ and $m_2 \Rightarrow^* m'$.
\end{theorem}
\begin{proof}
  By induction on the derivation of $m \Rightarrow^* m_2$ and \Cref{lemma:strip}.
\end{proof}

The validity of the confluence property allows us to prove the injectivity of
the convertibility relation for types.

\begin{corollary}\label[corollary]{corollary:inj-sort}
  $s_1 \simeq s_2$ implies $s_1 = s_2$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-implicit-fun}
  $\PiI{s}{x : A}{B} \simeq \PiI{s'}{x : A'}{B'}$ implies $s = s'$, $A \simeq A'$, and $B \simeq B'$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-explicit-fun}
  $\PiR{s}{x : A}{B} \simeq \PiR{s'}{x : A'}{B'}$ implies $s = s'$, $A \simeq A'$, and $B \simeq B'$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-implicit-sig}
  $\SigI{s}{x : A}{B} \simeq \SigI{s'}{x : A'}{B'}$ implies $s = s'$, $A \simeq A'$, and $B \simeq B'$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-explicit-sig}
  $\SigR{s}{x : A}{B} \simeq \SigR{s'}{x : A'}{B'}$ implies $s = s'$, $A \simeq A'$, and $B \simeq B'$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-monad}
  $\CM{A} \simeq \CM{B}$ implies $A \simeq B$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-implicit-action}
  $\ActI{\rho}{x : A}{B} \simeq \ActI{\rho'}{x : A'}{B'}$ implies $\rho = \rho'$, $A \simeq A'$, and $B \simeq B'$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-explicit-action}
  $\ActR{\rho}{x : A}{B} \simeq \ActR{\rho'}{x : A'}{B'}$ implies $\rho = \rho'$, $A \simeq A'$, and $B \simeq B'$.
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-ch}
  $\CH{A} \simeq \CH{B}$ implies $A \simeq B$. 
\end{corollary}

\begin{corollary}\label[corollary]{corollary:inj-hc}
  $\HC{A} \simeq \HC{B}$ implies $A \simeq B$.
\end{corollary}

\paragraph{\textbf{Weakening}}
Weakening allows for the addition of unused variables to a typing context. 
The logical level type system allows weakening as it is a fully structural type system.
On the other hand, the program level type system only allows weakening of unrestricted variables, 
i.e. variables whose types inhabit $\Un$.

\begin{lemma}[Renaming Arity]
  Given renaming $\xi$, if there is $A~\arity{\Proto}$, then there is $A[\xi]~\arity{\Proto}$.
\end{lemma}
\begin{proof}
  By induction on the structure of $A$.
\end{proof}

\begin{lemma}[Renaming Guarded]
  Given renaming $\xi$, 
  if there is $\forall x, y, \xi(x) = \xi(y) \implies x = y$, 
  then given variable $x$ and $A~\guard{x}$, there is $A[\xi]~\guard{\xi(x)}$.
\end{lemma}
\begin{proof}
  By induction on the structure of $A$.
\end{proof}

\begin{lemma}[Logical Weakening]
  If $\Gamma \vdash m : A$ and $\Gamma \vdash B : s$, 
  then $\Gamma, x : B \vdash m : A$ where $x \not\in \Gamma$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\Gamma \vdash m : A$.
  For more details, see file \textsf{sta\_weak.v} of our Rocq development
  which uses a De Bruijn indices representation for variables.
\end{proof}

\begin{lemma}[Program Weakening (Explicit)]
  If $\Theta ; \Gamma ; \Delta \vdash m : A$ and $\Gamma \vdash B : \Un$,
  then $\Theta ; \Gamma, x : B ; \Delta, x :_\Un B \vdash m : A$ where $x \not\in \Gamma$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\Theta ; \Gamma ; \Delta \vdash m : A$.
  For more details, see file \textsf{dyn\_weak.v} of our Rocq development
  which uses a De Bruijn indices representation for variables.
\end{proof}

\begin{lemma}[Program Weakening (Implicit)]
  If $\Theta ; \Gamma ; \Delta \vdash m : A$ and $\Delta \vdash B : \Ln$,
  then $\Theta ; \Gamma, x : B ; \Delta \vdash m : A$ where $x \not\in \Delta$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\Theta ; \Gamma ; \Delta \vdash m : A$.
  For more details, see file \textsf{dyn\_weak.v} of our Rocq development
  which uses a De Bruijn indices representation for variables.
\end{proof}
