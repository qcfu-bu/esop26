The process level type system of \TLLC{} is insufficient to ensure that
arbitrary process configurations enjoy global progress. 
This is because cyclic channel topologies are also considered to be well-typed.
However, we can still prove a weaker form of progress for a class of configurations
we call \emph{reachable configurations}. Intuitively, a reachable configuration is one
that can be reached from a well-typed singleton process through \Fork{}-operations.

Formally, we define the structure of \emph{spawning trees} to capture the
spawning relationships between parent-to-children processes. 
The syntax of spawning trees is given below.
\begin{center}
  \vspace{0.5em}
  \begin{tabular}{r L C L}
    spawning tree & \mcP, \mcQ & ::= & \Root{m}{ \{ ( c_i, \mcP_i ) \}_{i \in \mcI}, \{ \mcQ_j \}_{j \in \mcJ} } \\
                  &            & \;| & \Node{d}{m}{ \{ ( c_i, \mcP_i ) \}_{i \in \mcI}, \{ \mcQ_j \}_{j \in \mcJ} } \\
                  &            & \;| & \mcP \mid \mcQ
  \end{tabular}
  \vspace{0.5em}
\end{center}
Each tree is associated with a term $m$ that performs computation and a set of children processes
$\{ ( c_i, \mcP_i ) \}_{i \in \mcI}$ where $m$ communicates with each child process $\mcP_i$ through
channel $c_i$. It also contains a set of subtrees $\{ \mcQ_j \}_{j \in \mcJ}$ that are no longer in
communication with $m$ (i.e. they have been detached through \Close{}/\Wait{}-operations).
In the case of internal nodes, $d$ is the channel which $m$ uses to 
communicate with its parent process. 

The crucial ideal behind the spawning tree structure is that we are going to
define an alternative process semantics that operates on spawning trees. 
We will show that this alternative semantics can be simulated by the original process semantics.
Moreover, we will show that the spawning tree semantics enjoys global progress.
By defining reachable configurations as those that can be derived from
well-typed spawning trees, we can then prove that reachable configurations
enjoy global progress (induced by simulation). 

To make the typing rules of spawning trees easier to define, we first introduce 
the following notations for channel types and $\kappa \in \{ +, - \}$:
\begin{align*}
  \ch{+}{A} = \CH{A} && \neg{\ch{+}{A}} = \ch{-}{A} \\
  \ch{-}{A} = \HC{A} && \neg{\ch{-}{A}} = \ch{+}{A}
\end{align*}

We define the typing rules for 
spawning trees as follows:
\begin{mathpar}\small
  \inferrule
  { \overline{c_i \tL \ch{\kappa_i}{A_i}} ; \epsilon ; \epsilon \vdash m :\CM{\unit} \\
    \forall i \in \mcI,\ \neg{\ch{\kappa_i}{A_i}} \Vdash \mcP_i  \\
    \forall j \in \mcJ,\ \Vdash \mcQ_j }
  { \Vdash \Root{m}{ \{ ( c_i, \mcP_i ) \}_{i \in \mcI}, \{ \mcQ_j \}_{j \in \mcJ} } }
  \textsc{(Valid-Root)}
  \\
  \inferrule
  {  \overline{c_i \tL \ch{\kappa_i}{A_i}}, d \tL \ch{\kappa}{A} ; \epsilon ; \epsilon \vdash m :\CM{\unit} \\
    \forall i \in \mcI,\ \neg{\ch{\kappa_i}{A_i}} \Vdash \mcP_i \\ 
    \forall j \in \mcJ,\ \Vdash \mcQ_j }
  { \ch{\kappa}{A} \Vdash \Node{d}{m}{ \{ ( c_i, \mcP_i ) \}_{i \in \mcI}, \{ \mcQ_j \}_{j \in \mcJ} } }
  \textsc{(Valid-Node)}
\end{mathpar}
For the root node, we require that the term $m$ is well-typed in
channel context $\overline{c_i \tL \ch{\kappa_i}{A_i}}$ comprised of $\ch{\kappa_i}{A_i}$
channels connecting to its children processes $\mcP_i$.
The dual of each channel $\neg{\ch{\kappa_i}{A_i}}$ is propagated to typing the corresponding 
child process $\neg{\ch{\kappa_i}{A_i}} \Vdash \mcP_i$.
When typing an internal node, we require that $m$ is well-typed in a channel context
that also includes $d \tL \ch{\kappa}{A}$, i.e. the channel connecting to its parent process.

We define the \emph{flattening} operation $| \mcP |$ that converts a spawning tree into
a standard process configuration. The operation is defined as follows:
\begin{mathpar}\small
  \inferrule[Flatten-Root]
  { \forall i \in \mcI,\ | \mcP_i | = (d_i, P_i) \\ 
    \forall j \in \mcJ,\ | \mcQ_j | = Q_j }
  { | \Root{m}{ \{ ( c_i, \mcP_i ) \}_{i \in \mcI}, \{ \mcQ_j \}_{j \in \mcJ} } | = 
    \scope{\overline{c_i d_i}}{(\proc{m} \mid \overline{P_i})}  
    \mid \overline{Q_j} }

  \inferrule[Flatten-Node]
  { \forall i \in \mcI,\ | \mcP_i | = (d_i, P_i) \\ 
    \forall j \in \mcJ,\ | \mcQ_j | = Q_j }
  { | \Node{d}{m}{ \{ ( c_i, \mcP_i ) \}_{i \in \mcI}, \{ \mcQ_j \}_{j \in \mcJ} } | = 
    (d, \scope{\overline{c_i d_i}}{(\proc{m} \mid \overline{P_i})} \mid \overline{Q_j}) }
\end{mathpar}
The flattening operation recursively flattens each child process $\mcP_i$ into
a channel-process pair $(d_i, P_i)$ and each subtree $\mcQ_j$ into a process configuration $Q_j$.
It then composes $m$ with all the sub-processes in parallel. 
The channel pairs ${c_i, d_i}$ are restricted to ensure proper channel scoping.

We now connect the validity of spawning trees to the well-typedness of flattened process configurations
through \Cref{theorem:flatten-valid}.
\begin{theorem}[Flatten Valid]\label[theorem]{theorem:flatten-valid}
  If $\Vdash \mcP$ and $| \mcP | = P$, then $\Vdash P$
  and
  if ${\ch{\kappa}{A} \Vdash \mcP}$ and $| \mcP | = (d, P)$, then $d \tL \ch{\kappa}{A} \Vdash P$.
\end{theorem}
\begin{proof}
  By mutual induction on the derivation of $\Vdash \mcP$ and $A \Vdash \mcP$.

\noindent
\textbf{Case} (\textsc{Valid-Root}):
  From \textsc{Flatten-Root}, we have
  $| \mcP_i | = (d_i, P_i)$ for each child process $\mcP_i$ and
  $| \mcQ_j | = Q_j$ for each subtree $\mcQ_j$.
  By the induction hypothesis, we have $d_i \tL \neg{\ch{\kappa_i}{A_i}} \Vdash P_i$ for each $i \in \mcI$
  and $\Vdash Q_j$ for each $j \in \mcJ$.

  \noindent
  From the premise of \textsc{Valid-Root}, we have
  $\overline{c_i \tL \ch{\kappa_i}{A_i}} ; \epsilon ; \epsilon \vdash m :\CM{\unit}$.

  \noindent
  By \textsc{Expr}, we have
  $\overline{c_i \tL \ch{\kappa_i}{A_i}} \Vdash \proc{m}$.

  \noindent
  By applying \textsc{Par} repeated, we have
  $\overline{c_i \tL \ch{\kappa_i}{A_i}}, \overline{d_i \tL \neg{\ch{\kappa_i}{A_i}}} \Vdash (\proc{m} \mid \overline{P_i})$.

  \noindent
  By applying \textsc{Scope} repeatedly, we have
  $\Vdash \scope{\overline{c_i d_i}}{(\proc{m} \mid \overline{P_i})}$.

  \noindent
  By applying \textsc{Par} repeatedly, we have
  $\Vdash \scope{\overline{c_i d_i}}{(\proc{m} \mid \overline{P_i})} \mid \overline{Q_j}$
  which concludes this case.

\textbf{Case} (\textsc{Valid-Node}):
  From \textsc{Flatten-Node}, we have for each child process $\mcP_i$, $| \mcP_i | = (d_i, P_i)$ and
  for each subtree $\mcQ_j$, $| \mcQ_j | = Q_j$.
  By the induction hypothesis, we have $d_i \tL \neg{\ch{\kappa_i}{A_i}} \Vdash P_i$ for each $i \in \mcI$
  and $\Vdash Q_j$ for each $j \in \mcJ$.

  \noindent
  From the premise of \textsc{Valid-Node}, we have
  $\overline{c_i \tL \ch{\kappa_i}{A_i}}, d \tL \ch{\kappa}{A} ; \epsilon ; \epsilon \vdash m :\CM{\unit}$.

  \noindent
  By \textsc{Expr}, we have
  $\overline{c_i \tL \ch{\kappa_i}{A_i}}, d \tL \ch{\kappa}{A} \Vdash \proc{m}$.

  \noindent
  By applying \textsc{Par} repeated, we have
  $\overline{c_i \tL \ch{\kappa_i}{A_i}}, \overline{d_i \tL \neg{\ch{\kappa_i}{A_i}}}, d \tL \ch{\kappa}{A} \Vdash 
    (\proc{m} \mid \overline{P_i})$.

  \noindent
  By applying \textsc{Scope} repeatedly, we have
  $d \tL \ch{\kappa}{A} \Vdash \scope{\overline{c_i d_i}}{(\proc{m} \mid \overline{P_i})}$.

  \noindent
  By applying \textsc{Par} repeatedly, we have
  ${d \tL \ch{\kappa}{A} \Vdash \scope{\overline{c_i d_i}}{(\proc{m} \mid \overline{P_i})} \mid \overline{Q_j}}$
  which concludes this case.
\end{proof}

We now define the spawning tree semantics through the following reduction rules:

\begin{mathpar}\footnotesize
  \inferrule[Root-Fork]
  { }
  { 
    \Root{ 
      \letin{x}{\fork{y : A}{m}}{n} 
    }{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI}, 
      \{ \mcQ_j \}_{j \in \mcJ}
    } \\
    \quad\Rrightarrow
    \Root{
      n[c/x]   
    }{
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI} 
      \cup
      \{ (c, \Node{d}{m[d/x]}{\emptyset} ) \},
      \{ \mcQ_j \}_{j \in \mcJ}
    }
  }

  \inferrule[Node-Fork]
  { }
  { 
    \Node{d}{ 
      \letin{x}{\fork{y : A}{m}}{n} 
    }{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ}
    } \\
    \quad\Rrightarrow
    \Node{d}{
      n[c/x]   
    }{
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI} 
      \cup
      \{ (c, \Node{d'}{m[d'/x]}{\emptyset} ) \},
      \{ \mcQ_j \}_{j \in \mcJ}
    }
  }

  \inferrule[Root-Wait]
  { k \in \mcI \\ 
    \mcP_k = \Node{d_k}{\letin{y}{\close{d_k}}{n}}{ 
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    } \\
    \mcQ_{j_k} = 
    \Root{
      \letin{y}{\return{\ii}}{n}
    }{ 
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    }
  }
  { 
    \Root{
      \letin{x}{\wait{c_k}}{m}
    }{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ}
    } \\\\
    \quad\Rrightarrow
    \Root{
      \letin{x}{\return{\ii}}{m}
    }{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI \setminus \{k\}},
      \{ \mcQ_j \}_{j \in \mcJ \cup \{k\}}
    }
  }

  \inferrule[Node-Wait]
  { k \in \mcI \\ 
    \mcP_k = \Node{d_k}{\letin{y}{\close{d_k}}{n}}{ 
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    } \\
    \mcQ_{j_k} = 
    \Root{
      \letin{y}{\return{\ii}}{n}
    }{ 
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    }
  }
  { 
    \Node{d}{
      \letin{x}{\wait{c_k}}{m}
    }{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ}
    } \\\\
    \quad\Rrightarrow
    \Node{d}{
      \letin{x}{\return{\ii}}{m}
    }{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI \setminus \{k\}},
      \{ \mcQ_j \}_{j \in \mcJ \cup \{k\}}
    }
  }
  
  \inferrule[Root-Close]
  { k \in \mcI \\ 
    \mcP_k = \Node{d_k}{\letin{y}{\wait{d_k}}{n}}{ 
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    } \\
    \mcQ_{j_k} = 
    \Root{
      \letin{y}{\return{\ii}}{n}
    }{ 
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    }
  }
  { 
    \Root{
      \letin{x}{\close{c_k}}{m}
    }{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ}
    } \\\\
    \quad\Rrightarrow
    \Root{
      \letin{x}{\return{\ii}}{m}
    }{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI \setminus \{k\}},
      \{ \mcQ_j \}_{j \in \mcJ \cup \{k\}}
    }
  }

  \inferrule[Node-Close]
  { k \in \mcI \\ 
    \mcP_k = \Node{d_k}{\letin{y}{\wait{d_k}}{n}}{ 
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    } \\
    \mcQ_{j_k} = 
    \Root{
      \letin{y}{\return{\ii}}{n}
    }{ 
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    }
  }
  { 
    \Node{d}{
      \letin{x}{\close{c_k}}{m}
    }{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ}
    } \\\\
    \quad\Rrightarrow
    \Node{d}{
      \letin{x}{\return{\ii}}{m}
    }{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI \setminus \{k\}},
      \{ \mcQ_j \}_{j \in \mcJ \cup \{k\}}
    }
  }
\end{mathpar}
\clearpage

\begin{mathpar}\footnotesize
  \inferrule[Root-Send]
  { k \in \mcI \\ 
    \mcP_k = \Node{d_k}{
      \letin{y}{\recvR{d_k}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    } \\
    \mcI' = \{ i \in \mcI | c_i \in \FC{v} \} \\
    \mcP_k' = \Node{d_k}{
      \letin{y}{\return{\pairR{v}{d_k}{\Ln}}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k \cup \mcI'},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    }
  }
  { \Root{\letin{x}{
        \appR{\sendR{c_k}}{v}
      }{m}
    }{
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ}
    } \\\\
    \Rrightarrow
    \Root{
      \letin{x}{
        \return{c_k}
      }{m} 
    }{
      \{ (c_i, \mcP_i) \}_{i \in \mcI \setminus (\{ k \} \cup \mcI')} \cup \{ (c_k, \mcP_k') \},
      \{ \mcQ_j \}_{j \in \mcJ}
    }
  }

  \inferrule[Node-Send]
  { k \in \mcI \\ 
    \mcP_k = \Node{d_k}{
      \letin{y}{\recvR{d_k}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    } \\
    \mcI' = \{ i \in \mcI | c_i \in \FC{v} \} \\
    d \notin \FC{v} \\
    \mcP_k' = \Node{d_k}{
      \letin{y}{\return{\pairR{v}{d_k}{\Ln}}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k \cup \mcI'},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    }
  }
  { \Node{d}{\letin{x}{
        \appR{\sendR{c_k}}{v}
      }{m}
    }{
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ}
    } \\\\
    \Rrightarrow
    \Node{d}{
      \letin{x}{
        \return{c_k}
      }{m} 
    }{
      \{ (c_i, \mcP_i) \}_{i \in \mcI \setminus (\{ k \} \cup \mcI')} \cup \{ (c_k, \mcP_k') \},
      \{ \mcQ_j \}_{j \in \mcJ}
    }
  }

  \inferrule[Root-Recv]
  { k \in \mcI \\
    \mcP_k = \Node{d_k}{
      \letin{y}{\appR{\sendR{d_k}}{v}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    } \\
    \mcI' = \{ i \in \mcI_k | c_i \in \FC{v} \} \\
    \mcP_k' = \Node{d_k}{
      \letin{y}{\return{d_k}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k \setminus \mcI'},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    }
  }
  {
    \Root{
      \letin{x}{\recvR{c_k}}{m}
    } 
    {
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ}
    } \\\\
    \Rrightarrow
    \Root{
      \letin{x}{\return{\pairR{v}{c_k}{\Ln}}}{m}
    }{
      \{ (c_i, \mcP_i) \}_{i \in (\mcI \setminus \{ k \}) \cup \mcI'} \cup \{ (c_k, \mcP_k') \},
      \{ \mcQ_j \}_{j \in \mcJ}
    }
  }

  \inferrule[Node-Recv]
  { k \in \mcI \\
    \mcP_k = \Node{d_k}{
      \letin{y}{\appR{\sendR{d_k}}{v}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    } \\
    \mcI' = \{ i \in \mcI_k | c_i \in \FC{v} \} \\
    \mcP_k' = \Node{d_k}{
      \letin{y}{\return{d_k}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k \setminus \mcI'},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    }
  }
  {
    \Node{d}{
      \letin{x}{\recvR{c_k}}{m}
    } 
    {
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ}
    } \\\\
    \Rrightarrow
    \Node{d}{
      \letin{x}{\return{\pairR{v}{c_k}{\Ln}}}{m}
    }{
      \{ (c_i, \mcP_i) \}_{i \in (\mcI \setminus \{ k \}) \cup \mcI'} \cup \{ (c_k, \mcP_k') \},
      \{ \mcQ_j \}_{j \in \mcJ}
    }
  }

  \inferrule[Root-\underline{Send}]
  { k \in \mcI \\ 
    \mcP_k = \Node{d_k}{
      \letin{y}{\recvI{d_k}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    } \\
    \mcP_k' = \Node{d_k}{
      \letin{y}{\return{\pairI{o}{d_k}{\Ln}}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    }
  }
  { \Root{\letin{x}{
        \appI{\sendI{c_k}}{o}
      }{m}
    }{
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ}
    } \\\\
    \Rrightarrow
    \Root{
      \letin{x}{
        \return{c_k}
      }{m} 
    }{
      \{ (c_i, \mcP_i) \}_{i \in \mcI \setminus \{ k \}} \cup \{ (c_k, \mcP_k') \},
      \{ \mcQ_j \}_{j \in \mcJ}
    }
  }

  \inferrule[Node-\underline{Send}]
  { k \in \mcI \\ 
    \mcP_k = \Node{d_k}{
      \letin{y}{\recvI{d_k}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    } \\
    \mcP_k' = \Node{d_k}{
      \letin{y}{\return{\pairI{o}{d_k}{\Ln}}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    }
  }
  { \Node{d}{\letin{x}{
        \appI{\sendI{c_k}}{o}
      }{m}
    }{
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ}
    } \\\\
    \Rrightarrow
    \Node{d}{
      \letin{x}{
        \return{c_k}
      }{m} 
    }{
      \{ (c_i, \mcP_i) \}_{i \in \mcI \setminus \{ k \}} \cup \{ (c_k, \mcP_k') \},
      \{ \mcQ_j \}_{j \in \mcJ}
    }
  }

  \inferrule[Root-\underline{Recv}]
  { k \in \mcI \\
    \mcP_k = \Node{d_k}{
      \letin{y}{\appI{\sendI{d_k}}{o}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    } \\
    \mcP_k' = \Node{d_k}{
      \letin{y}{\return{d_k}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    }
  }
  {
    \Root{
      \letin{x}{\recvI{c_k}}{m}
    } 
    {
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ}
    } \\\\
    \Rrightarrow
    \Root{
      \letin{x}{\return{\pairI{o}{c_k}{\Ln}}}{m}
    }{
      \{ (c_i, \mcP_i) \}_{i \in \mcI \setminus \{ k \}} \cup \{ (c_k, \mcP_k') \},
      \{ \mcQ_j \}_{j \in \mcJ}
    }
  }

  \inferrule[Node-\underline{Recv}]
  { k \in \mcI \\
    \mcP_k = \Node{d_k}{
      \letin{y}{\appI{\sendI{d_k}}{o}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    } \\
    \mcP_k' = \Node{d_k}{
      \letin{y}{\return{d_k}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    }
  }
  {
    \Node{d}{
      \letin{x}{\recvI{c_k}}{m}
    } 
    {
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ}
    } \\\\
    \Rrightarrow
    \Node{d}{
      \letin{x}{\return{\pairI{o}{c_k}{\Ln}}}{m}
    }{
      \{ (c_i, \mcP_i) \}_{i \in \mcI \setminus \{ k \}} \cup \{ (c_k, \mcP_k') \},
      \{ \mcQ_j \}_{j \in \mcJ}
    }
  }
\end{mathpar}
\clearpage

\begin{mathpar}\footnotesize
  \inferrule[Node-Forward]
  { k \in \mcI \\ 
    \mcP_k = \Node{d_k}{
      \letin{y}{\recvR{d_k}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    } \\
    \mcI' = \{ i \in \mcI | c_i \in \FC{v} \} \\
    d \in \FC{v} \\
    \mcP_k' = \Node{c_k}{
      \letin{x}{ \return{c_k} }{m} 
    }{
      \{ (c_i, \mcP_i) \}_{i \in \mcI \setminus (\{ k \} \cup \mcI')},
      \{ \mcQ_j \}_{j \in \mcJ}
    }
  }
  { \Node{d}{\letin{x}{
        \appR{\sendR{c_k}}{v}
      }{m}
    }{
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ}
    } \\\\
    \Rrightarrow
    \Node{d}{
      \letin{y}{\return{\pairR{v}{d_k}{\Ln}}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k \cup \mcI'} \cup \{ (d_k, \mcP_k') \},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    }
  }

  \inferrule[Root-Child]
  { k \in \mcI \\
    \mcP_k \Rrightarrow \mcP_k' }
  { 
    \Root{m}{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ} 
    } 
    \Rrightarrow
    \Root{m}{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI \setminus \{k\}} \cup \{ ( c_k, \mcP_k' ) \}, 
      \{ \mcQ_j \}_{j \in \mcJ}
    }
  }

  \inferrule[Node-Child]
  { k \in \mcI \\
    \mcP_k \Rrightarrow \mcP_k' }
  { 
    \Node{d}{m}{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ} 
    } 
    \Rrightarrow
    \Node{d}{m}{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI \setminus \{k\}} \cup \{ ( c_k, \mcP_k' ) \}, 
      \{ \mcQ_j \}_{j \in \mcJ}
    }
  }

  \inferrule[Root-SubTree]
  { k \in \mcJ \\
    \mcQ_k \Rrightarrow \mcQ_k' }
  { 
    \Root{m}{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ} 
    } 
    \Rrightarrow
    \Root{m}{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ Q_j \}_{j \in \mcJ \setminus \{k\}} \cup \{ \mcQ_k' \}
    }
  }

  \inferrule[Node-SubTree]
  { k \in \mcJ \\
    \mcQ_k \Rrightarrow \mcQ_k' }
  { 
    \Node{d}{m}{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ} 
    } 
    \Rrightarrow
    \Node{d}{m}{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ Q_j \}_{j \in \mcJ \setminus \{k\}} \cup \{ \mcQ_k' \}
    }
  }

  \inferrule[Root-Expr]
  { 
    m \Leadsto m'
  }
  { 
    \Root{m}{
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ}
    }
    \Rrightarrow
    \Root{m'}{
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ} 
    }
  }

  \inferrule[Node-Expr]
  { 
    m \Leadsto m'
  }
  { 
    \Node{d}{m}{
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ}
    }
    \Rrightarrow
    \Node{d}{m'}{
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ} 
    }
  }
  
  \inferrule[Root-Unit]
  { k \in \mcJ \\ 
    \mcQ_k = \Root{\return{\ii}}{\emptyset, \emptyset} \\
    \Root{m}{
      \{ c_i, \mcP_i \}_{i \in \mcI},
      \{ c_j, \mcQ_j \}_{j \in \mcJ \setminus \{k\}}
    } 
    \Rrightarrow \mcP'
  }
  { 
    \Root{m}{
      \{ c_i, \mcP_i \}_{i \in \mcI},
      \{ c_j, \mcQ_j \}_{j \in \mcJ}
    }
    \Rrightarrow \mcP'
  }

  \inferrule[Node-Unit]
  { k \in \mcJ \\ 
    \mcQ_k = \Root{\return{\ii}}{\emptyset, \emptyset} \\ 
    \Node{d}{m}{
      \{ c_i, \mcP_i \}_{i \in \mcI},
      \{ c_j, \mcQ_j \}_{j \in \mcJ \setminus \{k\}}
    } 
    \Rrightarrow \mcP'
  }
  { 
    \Node{d}{m}{
      \{ c_i, \mcP_i \}_{i \in \mcI},
      \{ c_j, \mcQ_j \}_{j \in \mcJ}
    }
    \Rrightarrow \mcP'
  }
\end{mathpar}

In the rules above, the \textsc{Root-Fork} and \textsc{Node-Fork} rules
describe how a \Fork{}-operation spawns a new child process and adds it to the
set of children processes. The new child process is represented as an internal node.
The channel connecting the child to its parent is fresh.

The \textsc{Root-Wait}, \textsc{Node-Wait}, \textsc{Root-Close} and 
\textsc{Node-Close} rules describe how \Close{}/\Wait{}-operations
detach a child from its parent. The detached process is moved to the set of subtrees.

The \textsc{Root-Send} and \textsc{Node-Send} rules describe how a \Send{}-operation
sends a value to a child process. The child process must be waiting to receive a value
through a \Recv{}-operation. The sent value may contain channels that are connected to
other child processes. It is important to note that \textsc{Node-Send} only applies when
the sent value \emph{does not} contain the channel $d$ connecting to the parent, 
i.e. the side condition $d \notin \FC{v}$. When a value is sent, any child processes 
connected to channels in $\FC{v}$ are moved to be children of the receiving process.

The \textsc{Root-Recv} and \textsc{Node-Recv} rules describe how a \Recv{}-operation
receives a value from a child process. The child process must be waiting to send a value
through a \Send{}-operation. The received value may contain channels that are connected to
other child processes. When a value is received, any child processes connected to channels
in $\FC{v}$ are moved to be children of the receiving process. Note that, due to linearity,
the channel $d_k$ connecting the sending child to its parent cannot be in $\FC{v}$.
Thus, there is no side condition in \textsc{Node-Recv}. Moreover, this means that
cyclic channel dependencies cannot arise here.

The \textsc{Root-\underline{Send}}, \textsc{Node-\underline{Send}}, \textsc{Root-\underline{Recv}},
and \textsc{Node-\underline{Recv}} rules describe the sending and receiving of 
ghost messages through \SendI{} and \RecvI{} operations. Due to the fact that ghost messages
do not contain channels, there are no side conditions or changes to the spawning tree structure.

The \textsc{Node-Forward} rule describes how a \Send{}-operation can forward a
parent channel $d$ to a child process. The child process must be waiting to
receive a value. The sent value must contain the parent channel $d$, i.e. the
side condition $d \in \FC{v}$. When this happens, the child process takes over
the parent channel $d$ and tree is restructured so that the child process
becomes the new parent and the sending process (the original parent) becomes one
of its child processes. Other child processes that are connected to channels in
$\FC{v}$ are also moved to be children of the receiving process.

The \textsc{Root-Child}, \textsc{Node-Child}, \textsc{Root-SubTree}, and \textsc{Node-SubTree}
rules describe how a child process or subtree can take a reduction step.

The \textsc{Root-Expr} and \textsc{Node-Expr} rules describe how the expression
in a node can reduce.

The \textsc{Root-Unit} and \textsc{Node-Unit} rules describe how a subtree
that has finished (i.e. its expression is $\return{\ii}$ and it has no children or subtrees)
can be removed from the spawning tree.

We now state the simulation theorem between the spawning tree semantics
and the standard semantics (\Cref{appendix:process-semantics}).
With slight abuse of notation, we write $| \mcP |$ to denote just the process $P$
obtained by flattening the spawning tree $\mcP$.

\begin{theorem}[Spawning Tree Simulation]\label{theorem:spawning-tree-simulation}
  If $\Vdash \mcP$ or $A \Vdash \mcP$, then given $\mcP \Rrightarrow \mcP'$ 
  there is $| \mcP | \Rrightarrow | \mcP' |$. 
\end{theorem}
\begin{proof}
  By induction on the derivation of $\mcP \Rrightarrow \mcP'$.

\noindent
\textbf{Case} (\textsc{Root-Fork}):
  \begin{mathpar}\small
    \inferrule[Root-Fork]
    { }
    { 
      \Root{ 
        \letin{x}{\fork{y : A}{m}}{n} 
      }{ 
        \{ ( c_i, \mcP_i ) \}_{i \in \mcI}, 
        \{ \mcQ_j \}_{j \in \mcJ}
      } \\
      \quad\Rrightarrow
      \Root{
        n[c/x]   
      }{
        \{ ( c_i, \mcP_i ) \}_{i \in \mcI} 
        \cup
        \{ (c, \Node{d}{m[d/x]}{\emptyset} ) \},
        \{ \mcQ_j \}_{j \in \mcJ}
      }
    }
  \end{mathpar}
  Flattening both sides, we have:
  \begin{align*}
    &\scope{\overline{c_i d_i}}{(\proc{\letin{x}{\fork{y : A}{m}}{n}} \mid \overline{P_i})} \mid \overline{Q_j}
    \\
    &\scope{\overline{c_i d_i}}{(\scope{cd}{\proc{n[c/x]} \mid \proc{m[d/x]}} \mid \overline{P_i})} \mid \overline{Q_j}
  \end{align*}
  Repeated application of \textsc{Proc-Par} and \textsc{Proc-Scope} 
  and then \textsc{Proc-Fork} on the LHS gives the RHS, thus concluding this case.

\noindent
\textbf{Case} (\textsc{Node-Fork}): Similar to the \textsc{Root-Fork} case.

\noindent
\textbf{Case} (\textsc{Root-Wait}):
  \begin{mathpar}\small
  \inferrule[Root-Wait]
  { k \in \mcI \\ 
    \mcP_k = \Node{d_k}{\letin{y}{\close{d_k}}{n}}{ 
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    } \\
    \mcQ_{j_k} = 
    \Root{
      \letin{y}{\return{\ii}}{n}
    }{ 
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    }
  }
  { 
    \Root{
      \letin{x}{\wait{c_k}}{m}
    }{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ}
    } \\\\
    \quad\Rrightarrow
    \Root{
      \letin{x}{\return{\ii}}{m}
    }{ 
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI \setminus \{k\}},
      \{ \mcQ_j \}_{j \in \mcJ \cup \{k\}}
    }
  }
  \end{mathpar}
  Flattening both sides, we have:
  \begin{small}
  \begin{align*}
    &\scope{\overline{c_i d_i}}{ (
        \proc{\letin{x}{\wait{c_k}}{m}} 
        \mid \overline{P_i}_{(i \in \mcI \setminus \{k\})}
        \mid (
          \scope{\overline{c_{i_k}d_{i_k}}}{(\proc{\letin{y}{\close{d_k}}{n}} \mid \overline{P_{i_k}})}
          \mid \overline{Q_{j_k}}
        )
      )
    } \mid \overline{Q_j}
    \\
    &\scope{\overline{c_i d_i}_{(i \in \mcI \setminus \{k\})}}{(
      \proc{\letin{x}{\return{\ii}}{m}} 
      \mid \overline{P_i}_{(i \in \mcI \setminus \{k\})}
    )} 
    \mid \overline{Q_j} 
    \mid (
      \scope{\overline{c_{i_k} d_{i_k}}}{(
        \proc{\letin{y}{\return{\ii}}{n}} \mid \overline{P_{i_k}}
      )} \mid \overline{Q_{j_k}}
    )
  \end{align*}
  \end{small}
  Apply \textsc{Proc-Congr} to the LHS to rearrange the processes,
  then apply \textsc{Proc-Scope} and \textsc{Proc-Par} repeatedly
  to isolate the sub-configuration 
  $\scope{c_k d_k}{(\proc{\letin{x}{\wait{c_k}}{m}} \mid \proc{\letin{y}{\close{d_k}}{n}})}$.
  Finally, apply \textsc{Proc-Wait} to this sub-configuration
  to obtain the reduced configuration, which is structurally congruent
  to the RHS.


\noindent
\textbf{Case} (\textsc{Node-Wait}): Similar to the \textsc{Root-Wait} case.

\noindent
\textbf{Case} (\textsc{Root-Close}): Similar to the \textsc{Root-Wait} case.

\noindent
\textbf{Case} (\textsc{Node-Close}): Similar to the \textsc{Root-Wait} case.

\noindent
\textbf{Case} (\textsc{Root-Send}):
  \begin{mathpar}\small
  \inferrule[Root-Send]
  { k \in \mcI \\ 
    \mcP_k = \Node{d_k}{
      \letin{y}{\recvR{d_k}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    } \\
    \mcI' = \{ i \in \mcI | c_i \in \FC{v} \} \\
    \mcP_k' = \Node{d_k}{
      \letin{y}{\return{\pairR{v}{d_k}{\Ln}}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k \cup \mcI'},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    }
  }
  { \Root{\letin{x}{
        \appR{\sendR{c_k}}{v}
      }{m}
    }{
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ}
    } \\\\
    \Rrightarrow
    \Root{
      \letin{x}{
        \return{c_k}
      }{m} 
    }{
      \{ (c_i, \mcP_i) \}_{i \in \mcI \setminus (\{ k \} \cup \mcI')} \cup \{ (c_k, \mcP_k') \},
      \{ \mcQ_j \}_{j \in \mcJ}
    }
  }
  \end{mathpar}
  Flattening both sides, we have:
  \begin{small}
  \begin{align*}
    &\scope{\overline{c_i d_i}}{ (
        \proc{\letin{x}{\appR{\sendR{c_k}}{v}}{m}} 
        \mid \overline{P_i}_{(i \in \mcI \setminus \{k\})}
        \mid (
          \scope{\overline{c_{i_k}d_{i_k}}}{(\proc{\letin{y}{\recvR{d_k}}{n}} \mid \overline{P_{i_k}})}
          \mid \overline{Q_{j_k}}
        )
      )
    } \mid \overline{Q_j}
    \\
    &\nu{\overline{c_i d_i}_{(i \in (\mcI \setminus (\{k\} \cup \mcI')) \cup \{ k \})}}.(
      \proc{\letin{x}{\return{c_k}}{m}} 
      \mid \overline{P_i}_{(i \in \mcI \setminus (\{k\} \cup \mcI'))} \\
      &\qquad\mid
      \scope{\overline{c_{i_k} d_{i_k}}}{
      \scope{\overline{c_i d_i}_{(i \in \mcI')}}{(
        \proc{\letin{y}{\return{\pairR{v}{d_k}{\Ln}}}{n}} \mid \overline{P_{i_k}} \mid \overline{P_i}_{(i \in \mcI')}
      )}
      } \mid \overline{Q_{j_k}}
    )
    \mid \overline{Q_j}
  \end{align*}
  \end{small}
  Apply \textsc{Proc-Congr} to the LHS to rearrange the processes,
  then apply \textsc{Proc-Scope} and \textsc{Proc-Par} repeatedly
  to isolate the sub-configuration 
  $\scope{c_k d_k}{(\proc{\letin{x}{\appR{\sendR{c_k}}{v}}{m}} \mid \proc{\letin{y}{\recvR{d_k}}{n}})}$.
  Now, apply \textsc{Proc-Send} to this sub-configuration to obtain the reduced configuration
  $$
    \scope{c_k d_k}{(
      \proc{\letin{x}{\return{c_k}}{m}} 
      \mid \proc{\letin{y}{\return{\pairR{v}{d_k}{\Ln}}}{n}}
    )}
  $$
  Note that, by linearity, the channels $\{ c_i, d_i \}_{(i \in \mcI')}$ do not occur in 
  $\letin{x}{\return{c_k}}{m}$.
  Thus, structural congruence can be applied to move the scope of these channels to
  $$\scope{\overline{c_i d_i}_{(i \in \mcI')}}{
    (\proc{\letin{y}{\return{\pairR{v}{d_k}{\Ln}}}{n}} \mid \overline{P_i}_{(i \in \mcI')})}$$
  which gives us the desired result.

\noindent
\textbf{Case} (
  \textsc{Node-Send}, 
  \textsc{Root-Recv}
  \textsc{Node-Recv}
): Similar to the \textsc{Root-Send} case.

\noindent
\textbf{Case} (
  \textsc{Root-\underline{Send}}
  \textsc{Node-\underline{Send}}
  \textsc{Root-\underline{Recv}}
  \textsc{Node-\underline{Recv}}
): Similar to the \textsc{Root-Send} case.
The only difference is that scope restriction does not need to be applied
to move any channels since the ghost message $o$ does not contain channels.

\noindent
\textbf{Case} (\textsc{Node-Forward}):
  \begin{mathpar}\small
  \inferrule[Node-Forward]
  { k \in \mcI \\ 
    \mcP_k = \Node{d_k}{
      \letin{y}{\recvR{d_k}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    } \\
    \mcI' = \{ i \in \mcI | c_i \in \FC{v} \} \\
    d \in \FC{v} \\
    \mcP_k' = \Node{c_k}{
      \letin{x}{ \return{c_k} }{m} 
    }{
      \{ (c_i, \mcP_i) \}_{i \in \mcI \setminus (\{ k \} \cup \mcI')},
      \{ \mcQ_j \}_{j \in \mcJ}
    }
  }
  { \Node{d}{\letin{x}{
        \appR{\sendR{c_k}}{v}
      }{m}
    }{
      \{ ( c_i, \mcP_i ) \}_{i \in \mcI},
      \{ \mcQ_j \}_{j \in \mcJ}
    } \\\\
    \Rrightarrow
    \Node{d}{
      \letin{y}{\return{\pairR{v}{d_k}{\Ln}}}{n}
    }{
      \{ ( c_{i_k}, \mcP_{i_k} ) \}_{i_k \in \mcI_k \cup \mcI'} \cup \{ (d_k, \mcP_k') \},
      \{ \mcQ_{j_k} \}_{j_k \in \mcJ_k}
    }
  }
  \end{mathpar}
  Flattening both sides, we have:
  \begin{small}
  \begin{align*}
    &\scope{\overline{c_i d_i}}{ (
        \proc{\letin{x}{\appR{\sendR{c_k}}{v}}{m}} 
        \mid \overline{P_i}_{(i \in \mcI \setminus \{k\})}
        \mid (
          \scope{\overline{c_{i_k}d_{i_k}}}{(\proc{\letin{y}{\recvR{d_k}}{n}} \mid \overline{P_{i_k}})}
          \mid \overline{Q_{j_k}}
        )
      )
    } \mid \overline{Q_j}
    \\
    &\nu{\overline{c_{i_k} d_{i_k}}_{(i_k \in \mcI_k \cup \mcI' \cup \{ k \})}}.(
      \proc{\letin{y}{\return{\pairR{v}{d_k}{\Ln}}}{n}} 
      \mid \overline{P_{i_k}}_{(i_k \in \mcI_k \cup \mcI')} \\
      &\qquad\mid
      \scope{\overline{c_i d_i}_{(i \in \mcI \setminus (\{k\} \cup \mcI'))}}{(
        \proc{\letin{x}{\return{c_k}}{m}} 
        \mid \overline{P_i}_{(i \in \mcI \setminus (\{k\} \cup \mcI'))}
      )}
      \mid \overline{Q_j}
    ) \mid \overline{Q_{j_k}}
  \end{align*}
  \end{small}
  Apply \textsc{Proc-Congr} to the LHS to rearrange the processes,
  then apply \textsc{Proc-Scope} and \textsc{Proc-Par} repeatedly
  to isolate the sub-configuration 
  $\scope{c_k d_k}{(\proc{\letin{x}{\appR{\sendR{c_k}}{v}}{m}} \mid \proc{\letin{y}{\recvR{d_k}}{n}})}$.
  Now, apply \textsc{Proc-Send} to this sub-configuration to obtain the reduced configuration
  $$
    \scope{c_k d_k}{(
      \proc{\letin{x}{\return{c_k}}{m}} 
      \mid \proc{\letin{y}{\return{\pairR{v}{d_k}{\Ln}}}{n}}
    )}
  $$
  By symmetry of structural congruence, we have
  $$
    \scope{c_k d_k}{(
      \proc{\letin{y}{\return{\pairR{v}{d_k}{\Ln}}}{n}}
      \mid \proc{\letin{x}{\return{c_k}}{m}} 
    )}
  $$
  Since $\{ c_i, d_i \}_{(i \in \mcI \setminus (\{k\} \cup \mcI'))}$
  do not occur in $\letin{y}{\return{\pairR{v}{d_k}{\Ln}}}{n}$, we
  can apply structural congruence to move the scope of these channels to
  $$\scope{\overline{c_i d_i}_{(i \in \mcI \setminus (\{k\} \cup \mcI'))}}{
    (\proc{\letin{x}{\return{c_k}}{m}} \mid \overline{P_i}_{(i \in \mcI \setminus (\{k\} \cup \mcI'))})}$$
  which gives us the desired result.

\noindent
\textbf{Case} (
  \textsc{Root-Child},
  \textsc{Node-Child},
  \textsc{Root-SubTree},
  \textsc{Node-SubTree}
): By the induction hypothesis, we have $| \mcP_k | \Rrightarrow | \mcP_k' |$ or
  $| \mcQ_k | \Rrightarrow | \mcQ_k' |$.
  Repeated application of \textsc{Proc-Par} and \textsc{Proc-Scope} gives us the desired result.

\noindent
\textbf{Case} (\textsc{Root-Expr}, \textsc{Node-Expr}):
  By the assumption, we have $m \Leadsto m'$.
  Repeated application of \textsc{Proc-Par}, \textsc{Proc-Scope} 
  and then \textsc{Proc-Expr} gives us the desired result.

\noindent
\textbf{Case} (\textsc{Root-Unit}, \textsc{Node-Unit}):
  \begin{mathpar}\small
  \inferrule[Root-Unit]
  { k \in \mcJ \\ 
    \mcQ_k = \Root{\return{\ii}}{\emptyset, \emptyset} \\
    \Root{m}{
      \{ c_i, \mcP_i \}_{i \in \mcI},
      \{ c_j, \mcQ_j \}_{j \in \mcJ \setminus \{k\}}
    } 
    \Rrightarrow \mcP'
  }
  { 
    \Root{m}{
      \{ c_i, \mcP_i \}_{i \in \mcI},
      \{ c_j, \mcQ_j \}_{j \in \mcJ}
    }
    \Rrightarrow \mcP'
  }
  \end{mathpar}
  Flattening the LHS, we have:
  $$
    \scope{\overline{c_i, d_i}}{(
      \proc{m} \mid \overline{P_i} \mid \proc{\return{\ii}} \mid \overline{Q_j}_{(j \in \mcJ \setminus \{k\})}
    )}
  $$
  From the induction hypothesis, we have
  $$
    \scope{\overline{c_i, d_i}}{(
      \proc{m} \mid \overline{P_i} \mid \overline{Q_j}_{(j \in \mcJ \setminus \{k\})}
    )} \Rrightarrow | \mcP' |
  $$
  Repeated application of \textsc{Proc-Par} and \textsc{Proc-Scope}
  and then \textsc{Proc-Congr} to the induction hypothesis gives us the desired result.

\end{proof}