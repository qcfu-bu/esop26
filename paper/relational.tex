Earlier in the introduction section, we showed a sketch of how dependent session types
can be used for certified concurrent programming through the example of a concurrent queue.
In this section, we provide a detailed account of how we can use dependent session types
to construct a generic map-reduce system. Similarly to the queue example, we will verify
the correctness of the map-reduce system by relating it to sequential operations on trees.

Intuitively, map-reduce creates a tree of concurrently executing workers as illustrated in
\Cref{fig:map-reduce}. Initially, the client partitions the data into smaller chunks and sends them to
the leaf workers of the tree. Next, each leaf worker applies a user-specified
function $f$ to each of its received data chunks and sends the results to its parent worker.
When an internal worker receives results from its children, it combines the results using another
user-specified binary function $g$. This procedure continues until the root worker computes
the final result and sends it back to the client. Due to the fact that workers without
data dependencies can operate concurrently, the overall system can achieve significantly better
performance than sequential implementations of the same operations.
\vspace{-0.3em}
\begin{figure}[H]
\begin{tikzpicture}[
  treenode/.style = {shape=rectangle, rounded corners,
                     draw, align=center,
                     fill=blue!20},
  client/.style   = {shape=rectangle, draw=red!60, fill=red!5},
  root/.style     = {circle,draw},
  env/.style      = {treenode},
  dummy/.style    = {circle,draw,fill=black!2},
  grow = right,
  edge from parent/.style = {draw, -latex},
  sloped,
  level distance=2cm,
  level 1/.style={sibling distance=4em},
  level 2/.style={sibling distance=2em}
]
  \node [client]            (c0) {client};
  \node [root, right= 2cm of c0] (t0) {}
    child { node [dummy] {}
      child { node [env] {$a_4$} }
      child { node [env] {$a_3$} }
    }
    child { node [dummy] {}
      child { node [env] {$a_2$} }
      child { node [env] {$a_1$} }
    };
\draw[-latex] (c0.east) -- (t0.west);
\end{tikzpicture}
\vspace{-0.5em}
\caption{Tree Diagram of Map-Reduce}
\label{fig:map-reduce}
\end{figure}

The first step in constructing the map-reduce system is to define the kinds of operations
that can be performed by the system.
\begingroup
\small
\addtolength{\jot}{-0.2em}
\begin{align*}
  \Inductive\ \textsf{opr}(A : \Un) :=\ &\textsf{Free}  : \textsf{opr}(A) \\
  \mid\ &\textsf{Map}   : \forall \{B : \Un\}\ (f : A \rightarrow B) \rightarrow \textsf{opr}(A) \\
  \mid\ &\textsf{Reduce}: \forall \{B : \Un\}\ (f : A \rightarrow B)\ (g : B \rightarrow B \rightarrow B) \rightarrow \textsf{opr}(A)
\end{align*}
\endgroup

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End:
