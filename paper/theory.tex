\subsection{Core TLL}\label{sec:core-tll}
In this section, we give a brief summary of the Two-Level Linear dependent type theory (TLL)~\cite{fu23}. 
TLL is a dependent type theory that combines 
Martin-L\"{o}f-style dependent types~\cite{martinlof} 
with linear types~\cite{girard,wadler1990}. 
Notably, TLL supports \emph{essential linearity}~\cite{luo} through the use of
a stratified ``two-level'' typing system: the \emph{logical} level and the \emph{program} level. 
The typing judgments of the two levels are written as follows:
\begin{center}
\vspace{0.5em}
\begin{tikzpicture}[
    node distance=2.4cm,
    >=stealth, auto,
    every state/.style={rectangle, draw, rounded corners}
]
\node[state, fill=blue!5] (l)                {\small$\Gamma \vdash m : A\ \text{(Logical Typing)}$};
\node[state, fill=red!5]  (p) [right=of l]   {\small$\Gamma ; \Delta \vdash m : A\ \text{(Program Typing)}$};
\path[-latex,transform canvas={yshift=+1.5ex}] (l.east) edge node {\footnotesize{provides types}} (p.west);
\path[-latex,transform canvas={yshift=-1.5ex}] (p.west) edge node {\footnotesize{subjects to verify}} (l.east);
\end{tikzpicture}
\vspace{0.5em}
\end{center}

First, the \emph{logical} level is a standard dependent type system that supports unrestricted 
usage of types and terms. The primary purpose of the logical level is to provide typing rules
for types which will be used at the logical level. For example, the rules for dependent 
function type ($\Pi$-types) formation are defined at the logical level as follows:
\begin{mathpar}
  \inferrule[Explicit-Fun]
  { \Gamma \vdash A : s \\
    \Gamma, x : A \vdash B : r }
  { \Gamma \vdash \PiR{t}{x : A}{B} : t }

  \inferrule[Implicit-Fun]
  { \Gamma \vdash A : s \\
    \Gamma, x : A \vdash B : r }
  { \Gamma \vdash \PiI{t}{x : A}{B} : t }
\end{mathpar}
The symbols $s, r, t$ range over the \emph{sorts} of type universes, i.e. 
$\Un$ or $\Ln$. These sorts are used to classify types into two categories: 
unrestricted types ($A : \Un$) and linear types ($A : \Ln$).
Program level terms which inhabit unrestricted types can be freely duplicated or discarded,
while those which inhabit linear types must be used exactly once.
Note that this usage restriction is \emph{not} enforced at the logical level
as the logical level typing judgment is completely structural.
This is safe because the logical level will never be executed at runtime and 
is only used for type checking and verification. Thus, multiple uses of
a linear resource at the logical level will not lead to any runtime errors.

At the program level, the typing judgment $\Gamma ; \Delta \vdash m : A$ is used to
exclusively type \emph{terms}. In other words, no rules for forming types are defined
at the program level. All the types used in $\Gamma$, $\Delta$, $m$ and $A$ must be well-formed
according to the logical level typing judgment. This typing judgment possesses two contexts:
$\Gamma$ of all variables in scope, and $\Delta$ of all variables that are computationally relevant
in program $m$. Context $\Delta$ is crucial for enforcing linearity at the program level.
For example, consider the $\lambda$-abstraction rules:
\begin{mathpar}
  \inferrule[Explicit-Lam]
  { \Gamma, x : A ; \Delta, x :_s A \vdash m : B \\ 
    \Delta \triangleright t }
  { \Gamma ; \Delta \vdash \lamR{t}{x : A}{m} : \PiR{t}{x : A}{B} }

  \inferrule[Implicit-Lam]
  { \Gamma, x : A ; \Delta \vdash m : B \\
    \Delta \triangleright t }
  { \Gamma ; \Delta \vdash \lamI{t}{x : A}{m} : \PiI{t}{x : A}{B} }
\end{mathpar}
In \textsc{Explicit-Lam}, we can see that the bound variable $x$ is added to
both contexts $\Gamma$ and $\Delta$. This indicates that $x$ is a variable which
can be used both logically (in types and ghost values) through $\Gamma$, and
computationally (in real values) through $\Delta$. On the other hand, in the
\textsc{Implicit-Lam} rule, $x$ is only added to $\Gamma$ but not $\Delta$.
This indicates that $x$ is a ghost variable which can only be used logically.
A ubiquitous example of ghost variables are type parameters in polymorphic functions.
For example, the polymorphic identity function can be implemented as
\begin{align*}
  \lamI{\Un}{A : \Un}{\lamR{\Un}{x : A}{x}}
\end{align*}
which has the type $\PiI{\Un}{A : \Un}{\PiR{\Un}{x : A}{A}}$.
Arguments to implicit functions are typed at the logical level, thus
allowing polymorphic functions to be instantiated with a type as an argument.
Additionally, as demonstrated in the examples of prior sections,
ghost variables also facilitate program verification by statically describing 
abstractions and invariants of program states.

In the two $\lambda$-abstraction rules above, 
the premise $\Delta \triangleright t$ is a simple side condition that states: if
$t = \Un$, then all variables in $\Delta$ must be unrestricted. In other words,
the $\lambda$-abstractions that can be applied unrestrictedly (with $t = \Un$)
are not allowed to capture linearly typed variables from $\Delta$. This is
similar to the restriction imposed on closures implementing the $\textsf{Fn}$
trait (i.e. those that can be called multiple times) in Rust~\cite{rust} where
capturing of mutable references is prohibited. If such a restriction is not
imposed, then evaluating a $\lambda$-abstraction (that captures a linear
variable) twice may lead to unsafe memory accesses such as double frees or
use-after-frees.

The application rules for both explicit and implicit functions are as follows:
\begin{mathpar}
  \inferrule[Explicit-App]
  { \Gamma ; \Delta_1 \vdash m : \PiR{t}{x : A}{B} \\ 
    \Gamma ; \Delta_2 \vdash n : A }
  { \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash \appR{m}{n} : B[n/x] }

  \inferrule[Implicit-App]
  { \Gamma ; \Delta \vdash m : \PiI{t}{x : A}{B} \\ 
    \Gamma \vdash n : A }
  { \Gamma ; \Delta \vdash \appI{m}{n} : B[n/x] }
\end{mathpar}
In \textsc{Explicit-App}, the argument $n$ is a real value which must be typed
at the program level. The $\dotcup$ operator merges the two program context
$\Delta_1$ and $\Delta_2$ by contracting unrestricted variables and requiring
that linear variables be disjoint, thus preventing the sharing of linear
resources. In \textsc{Implicit-App}, the argument $n$ is a ghost value that is
typed at the logical level. Due to the fact that ghost values are erased prior
to runtime, the program context $\Delta$ in the conclusion only tracks the
computationally relevant variables used in $m$. Notice how in \textsc{Explicit-App}, 
the argument $n$ is substituted into the return type $B$. This allows types to depend 
on program level terms regardless of whether they are of linear or unrestricted types.

\paragraph{\textbf{Usage vs Uniqueness}}
Compared to other linear dependent type
theories~\cite{qtt,nothing,llf,vakar14,luo} which only enforce the linear
\emph{usage} of resources, the TLL type system prevents the \emph{sharing} of
linear resources as well. This is similar to the subtle distinction between
linear logic~\cite{girard} and bunched implications~\cite{ohearn99,ohearn03}
described by O'Hearn. 
Consider a linear function $f$, in the aforementioned dependent type theories,
of some type $A \multimap B$. When function $f$ is applied to some argument $v$
of type $A$, the argument $v$ is guaranteed to be used exactly once in the 
\emph{body} of $f$. Notice that this notion of linearity does not guarantee that
$f$ has unique access to $v$. If $v$ was obtain from some $!$-exponential or
$\omega$-quantity (the sharable quantity in graded systems \cite{qtt,nothing}),
then there may be other aliases of $v$ which can be used outside of $f$.

Wadler, in his seminal work~\cite{wadler1991}, made a similar distinction
between linearity and uniqueness in the context of functional programming,
noting that implicit uses of \emph{promotion} and \emph{dereliction} in linear
logic can lead to violations of uniqueness.  He coins the term \emph{steadfast
types} to refer to type systems that enforce both linearity and uniqueness. In
this sense, TLL is steadfast as its \emph{sort-uniqueness} property (i.e. types
uniquely inhabit either $\Un$ or $\Ln$) prohibits the implicit promotion and
dereliction of linear types, thus preventing the sharing of linear resources.
The heap semantics~\cite{turner99} of TLL shows that its programs enjoy the 
\emph{single-pointer} property which is a consequence of uniqueness at runtime.  In
the context of concurrency, the steadfast type system of TLL makes it especially
suitable for integration with session types: linear usage prevents replaying of
communication protocols and uniqueness ensures that a communication channel has
a single owner.

\subsection{Dependent Session Types of \TLLC{}}
In this section, we formally present the dependent session types of \TLLC{}.

\paragraph{\textbf{Basic Protocols and Channel Types}}
The intuitionistic session types of \TLLC{} are decoupled into \emph{protocols} and \emph{channel types}. 
The rule for forming protocols is as follows:
\begin{mathpar}
  \inferrule[Proto] 
  { \Gamma \vdash }
  { \Gamma \vdash \Proto : \Un }

  \inferrule[Explicit-Action]
  { \Gamma, x : A \vdash B : \Proto }
  { \Gamma \vdash \ActR{\rho}{x : A}{B} : \Proto }

  \inferrule[Implicit-Action]
  { \Gamma, x : A \vdash B : \Proto }
  { \Gamma \vdash \ActI{\rho}{x : A}{B} : \Proto }

  \inferrule[End]
  { \Gamma \vdash }
  { \Gamma \vdash \End : \Proto }

  \text{where } \rho \in \{!, ?\}
\end{mathpar}
Here, the \textsc{Proto} rule introduces the \Proto{} type which is the type of all protocols. 
Note that \Proto{} is an unrestricted type, thus protocols can be freely duplicated or discarded.
The \textsc{Explicit-Action} and \textsc{Implicit-Action} rules form dependent protocols which 
inhabit the \Proto{} type. The \textsc{End} rule marks the termination of a protocol.

Once a protocol is defined, we can form channel types using the following rules:
\begin{mathpar}
  \inferrule[ChType]
  { \Gamma \vdash A : \Proto }
  { \Gamma \vdash \CH{A} : \Ln }

  \inferrule[HcType]
  { \Gamma \vdash A : \Proto }
  { \Gamma \vdash \HC{A} : \Ln }
\end{mathpar}
Notice that the channel type constructors $\CH{\cdot}$ and $\HC{\cdot}$
lift protocols, which are unrestricted values, into linear types. This means that
channels must be used exactly once. Furthermore, as explained in the previous
section, the unique ownership of linear types in TLL ensures that only a single
entity has access to a channel at any point in time, thus preventing race conditions.

\paragraph{\textbf{Recursive Protocols}}
Recursive protocols can be formed using the $\fix{x : A}{m}$ construct:
\begin{mathpar}
  \inferrule[Fixpoint]
  { \Gamma, x : A \vdash m : A \\ 
    A\ \text{is an \emph{arity} ending on } \Proto \\
    x\ \text{is \emph{guarded} by protocol action in}\ m }
  { \Gamma \vdash \fix{x : A}{m} : A }
\end{mathpar}
For a $\fix{x : A}{m}$ term, we require that $A$ be an \emph{arity} ending on \Proto{}.
This prevents $\mu$ from introducing logical inconsistencies as it can only be used to
construct protocols and not proofs for arbitrary propositions. To ensure that protocols
defined through $\fix{x : A}{m}$ can be productively unfolded, recursive usages of $x$ must be
syntactically \emph{guarded} behind a protocol action in $m$. This enforces the 
\emph{contractiveness} condition for recursive session types~\cite{gay10}. Both the
arity and guardedness conditions are stable under substitution. Due to space limitations,
we present the rules of arities and guardedness in the appendix.

The difficulty of integrating recursive protocols in classical session type
systems is well documented~\cite{gay20}. The key challenge is to define a
suitable \emph{duality} operator that commutes with recursion. The following
example is due to Bernardi and Hennessy~\cite{bernardi16}. Suppose we define a 
reasonable, but naive, duality operator $(\cdot)^\bot$ which simply flips $!$
and $?$ in protocols.  For the dual of recursive protocol $\mu{X}.{?X}.X$, if we
first apply duality and then unfold the recursion, we get:
\begin{align*}
  (\mu{X}.{?X}.X)^\bot  = \mu{X}.{!X}.X =\; !(\mu{X}.{!X}.X).(\mu{X}.{!X}.X)
\end{align*} 
On the other hand, if we first unfold the recursion and then apply duality, we get:
\begin{align*}
  (\mu{X}.{?X}.X)^\bot = (?(\mu{X}.{?X}.X).(\mu{X}.{?X}.X))^\bot =\; !(\mu{X}.{?X}.X).(\mu{X}.{!X}.X)
\end{align*} 
Notice that the resulting protocols do not agree on the type of the sent message.
While solutions have been proposed to address this issue~\cite{bernardi16,bernardi14},
they do not generalize to dependent session types due to the presence of arbitrary
type-level computation. In \TLLC{}, the separation of protocols and channels types
allows us to sidestep the duality problem entirely. Suppose we define our previously
problematic recursive protocol in \TLLC{} as follows:
\begin{align*}
  T \triangleq \fix{X : \Proto}{?(\_ : X). X} =\; ?\big(\_ : \fix{X : \Proto}{?(\_ : X). X}\big).\ \fix{X : \Proto}{?(\_ : X). X}
\end{align*}
When viewed through the lens of channel type constructors $\CH{\cdot}$ and $\HC{\cdot}$,
the actions specified by the unfolded protocol are correctly dual to each other.
More specifically, a channel of type $\CH{T}$ receives a protocol of type $T$ whereas
a channel of type $\HC{T}$ sends a protocol of type $T$.

\paragraph{\textbf{Concurrency Monad}}
In order to integrate concurrency into the pure functional core of TLL, \TLLC{} 
introduces a concurrency monad $\mcC$ which encapsulates the side effects 
of concurrent computations. The concurrency monad is defined in the following \textsc{$\mcC$Type} rule.

\vspace{-1em}
\begin{mathpar}
  \inferrule[$\mcC$Type]
  { \Gamma \vdash A : s }
  { \Gamma \vdash \CM{A} : \Ln }

  \inferrule[Return]
  { \Theta ; \Gamma ; \Delta \vdash m : A }
  { \Theta ; \Gamma ; \Delta \vdash \return{m} : \CM{A} }

  \inferrule[Bind]
  { \Gamma \vdash B : s \\
    \Theta_1 ; \Gamma ; \Delta_1 \vdash m : \CM{A} \\\\
    \Theta_2 ; \Gamma, x : A ; \Delta_2 \vdash n : \CM{B} }
  { \Theta_1 \dotcup \Theta_2 ; \Gamma ; \Delta_1 \dotcup \Delta_2 \vdash \letin{m}{x}{n} : \CM{B} }
\end{mathpar}

To account for the addition of communication channels, the program typing judgment
${\Gamma ; \Delta \vdash m : A}$ of TLL is extended into ${\Theta ; \Gamma ; \Delta \vdash m : A}$.
The new context $\Theta$ tracks all the channels used in $m$. The \textsc{Bind} rule above merges 
the channel contexts $\Theta_1$ and $\Theta_2$ in its conclusion similarly to how program contexts
are merged. This prevents channels from being shared between $m$ and $n$.

As explained in \Cref{sec:message-specification}, the protocol actions $!(x : A).B$ and $?(x : A).B$
are abstract constructs that need to be interpreted through channel types. Since $\CH{\cdot}$ and $\HC{\cdot}$
interpret protocol actions in opposite ways, we only present the typing rules for $\CH{\cdot}$ below.
\begin{mathpar}
  \inferrule[Explicit-Send-CH]
  { \Theta ; \Gamma ; \Delta \vdash c : \CH{\ActR{!}{x : A}{B}}}
  { \Theta ; \Gamma ; \Delta \vdash \Send\ c : \PiR{\Ln}{x : A}{\CM{\CH{B}}} }

  \inferrule[Explicit-Recv-CH]
  { \Theta ; \Gamma ; \Delta \vdash c : \CH{\ActR{?}{x : A}{B}}}
  { \Theta ; \Gamma ; \Delta \vdash \Recv\ c : \CM{\SigR{\Ln}{x : A}{\CH{B}}} }

  \inferrule[Implicit-Send-CH]
  { \Theta ; \Gamma ; \Delta \vdash c : \CH{\ActI{!}{x : A}{B}}}
  { \Theta ; \Gamma ; \Delta \vdash \SendI\ c : \PiI{\Ln}{x : A}{\CM{\CH{B}}} }

  \inferrule[Implicit-Recv-CH]
  { \Theta ; \Gamma ; \Delta \vdash c : \CH{\ActI{?}{x : A}{B}}}
  { \Theta ; \Gamma ; \Delta \vdash \RecvI\ c : \CM{\SigI{\Ln}{x : A}{\CH{B}}} }
\end{mathpar}

For the \textsc{Explicit-Send-CH} rule, a channel of type $\CH{!(x : A).B}$ is
applied to the \Send{} operator. This produces a function which takes a real
value $v$ of type $A$ and returns a concurrent computation of type
$\CM{\CH{B[v/x]}}$ which represents the continuation of the protocol after
sending a real value of type $A$. When this monadic value is bound by rule
\textsc{Bind} and executed at runtime, the value $v$ will be sent on channel
$c$. The elided \textsc{Explicit-Recv-HC} dual rule receives on a channel of
type $\HC{!(x : A).B}$ which produces a (monadic) dependent pair similarly to
\textsc{Explicit-Recv-CH}. The first component of the pair is the value of
type $A$ that was received, and the second component is a channel of type
$\HC{B[v/x]}$ representing the continuation of the protocol. Notice that due to
the linearity of the $\mcC$ monad, all of the intermediate monadic values are
guaranteed to be executed.

The implicit send and receive rules are similar to their explicit counterparts,
except that they send and receive ghost values instead of real values. This 
distinction manifests by having the \SendI{} and \RecvI{} operators produce
implicit functions and implicit pairs respectively. When the implicit function
of \textsc{Implicit-Send-CH} is applied to a ghost argument using
\textsc{Implicit-App} (\Cref{sec:core-tll}), the ghost argument will be erased
prior to runtime. Similarly, the first component of the implicit pair produced
by \textsc{Implicit-Recv-CH} is also an erased ghost value. The underlying type
system of TLL ensures that these ghost values will only be used logically, thus
are safe to erase.

The final communication rules govern the creation and termination of channels:

\vspace{-1em}
\begin{small}
\begin{mathpar}
  \inferrule[Fork]
  { \Theta ; \Gamma, x : \CH{A} ; \Delta, x :_\Ln \CH{A} \vdash m : \CM{\unit} }
  { \Theta ; \Gamma ; \Delta \vdash \Fork (x : \CH{A})\ \With\ m : \CM{\HC{A}} }
  \and\hspace{-0.5em}
  \inferrule[Close]
  { \Theta; \Gamma ; \Delta \vdash c : \CH{\End} }
  { \Theta ; \Gamma ; \Delta \vdash \Close\ c : \CM{\unit} }
  \and\hspace{-1.5em}
  \inferrule[Wait]
  { \Theta; \Gamma ; \Delta \vdash c : \HC{\End} }
  { \Theta ; \Gamma ; \Delta \vdash \Wait\ c : \CM{\unit} }
\end{mathpar}
\end{small}

The \textsc{Fork} rule is used for creating a child process which concurrently
executes the monadic computation $m$. The child process is provided with a fresh
channel of type $\CH{A}$ which is bound to the variable $x$ in $m$. Dually, the
parent process obtains the channel endpoint of type $\HC{A}$, which can be used
to communicate with the spawned process.
