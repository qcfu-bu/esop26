Session types in \TLLC{} are \emph{minimalistic} in design and yet surprisingly expressive
due to the presence of dependent types. Through examples, we provide an overview of
how dependent session types facilitate certified concurrent programming in \TLLC{}.

\subsection{Message Specification}\label{sec:message-specification}
An obvious, but important, use of dependent session types is the precise specification
of message properties communicated between parties. This is useful in practical network
systems where the content of messages may depend on the value of a prior request.
Consider the following protocol:
\begin{align*}
  !(\textit{sz}: \textsf{nat}).\
  ?(\textit{msg}: \textsf{bytes}).\ ?\{\textsf{sizeOf}(\textit{msg}) = \textit{sz}\}.\ \End
\end{align*}
Informally speaking, this protocol first expects a natural number \textit{sz} to be sent
followed by receiving a byte string \textit{msg}. In simple session type systems without
dependency, there would be no way of specifying the relationship between \textit{sz} and
\textit{msg}. However, dependent session types allow us to express relations between messages.
Notice in the third interaction expected by the protocol, the party sending \textit{msg} must
provide a \emph{proof} that the size of \textit{msg} is indeed \textit{sz} according to
an agreed upon \textsf{sizeOf} function. Finally, the protocol terminates with $\End$ and
communication ends. Notice that the proof here, as indicated by the curly braces, is a
\emph{ghost message}: it is used for type checking and erased prior to runtime. Even though
the proof does not participate in actual communication, the necessity for the send of
\textit{msg} to provide such a proof ensures that the protocol is followed correctly.

This example showcases the main primitives for constructing dependent protocols in
\TLLC{}: the $!(x : A).B$ and $?(x : A).B$ \emph{protocol actions}. The syntax of these
constructs take inspiration from binary session types~\cite{gay10,wadler12} and label
dependent session types~\cite{ldst}, however the meaning of these constructs in \TLLC{} is
subtly different. In prior works, the $!$ marker indicates that the channel is to send
and the $?$ marker indicates that the channel is to receive. In \TLLC{}, neither marker
expresses sending or receiving per se, but rather an abstract action that needs to be
interpreted through a \emph{channel type}. Hence, the description of the messaging protocol
above is stated to be informal. To assign a precise meaning to the protocol, we need to
view it through the lenses of channel types:
\begin{align*}
  &\CH{!(\textit{sz}: \textsf{nat}).\ ?(\textit{msg}: \textsf{bytes}).\ ?\{\textsf{sizeOf}(\textit{msg}) = \textit{sz}\}.\ \End} \\
  &\HC{!(\textit{sz}: \textsf{nat}).\ ?(\textit{msg}: \textsf{bytes}).\ ?\{\textsf{sizeOf}(\textit{msg}) = \textit{sz}\}.\ \End}
\end{align*}
Here, these two channel types are constructed using \emph{dual} channel type
constructors: $\CH{\cdot}$ and $\HC{\cdot}$.  The $\CH{\cdot}$ constructor
interprets $!$ as sending and $?$ as receiving while the $\HC{\cdot}$
constructor interprets $!$ as receiving and $?$ as sending. In other words, dual
channel types interpret protocol actions in opposite ways. These constructors act similarly
to the duality of left and right rules for intuitionistic session types~\cite{caires10}.
Unlike intuitionistic session types which require the base type system to be
based on sequent calculus, our channel types can be integrated into the type
systems of functional languages so long as linear types are supported.

\subsection{Dependent Ghost Secrets}
Dependent ghost messages have interesting applications when it comes to message specification.
Consider the following encoding of a idealized Shannon cipher protocol:
\begin{align*}
  H(E, D) &:= \forall \{k : \mcK\}\;\{m : \mcM\} \rightarrow D(k, E(k, m)) =_{\mcM} m
\qquad\text{(correctness property)}
  \\
  \mcE(E, D) &:=\ !\{k : \mcK\}.\ !\{m : \mcM\}.\ !(c : \mcC).\ !\{H(E,D) \times (c =_\mcC E(k, m))\}.\ \End
\end{align*}
Given public encryption and decryption functions
$E: \mcK \times \mcM \rightarrow \mcC$ and
$D: \mcK \times \mcC \rightarrow \mcM$ respectively, the protocol $\mcE(E,D)$
begins by sending ghost messages: key $k$ of type $\mcK$ and message $m$ of type
$\mcM$.  Next, the ciphertext $c$ of type $\mcC$, indicated by round
parenthesis, is actually sent to the client. Finally, the last ghost message
sent is a proof object witnessing the correctness property of the
protocol: $c$ is obtained by encrypting $m$ with key $k$.  Observe that for the
overall protocol, \emph{only} ciphertext $c$ will be sent at runtime while the
other messages (secrets) are erased. The Shannon cipher protocol basically
forces communicated messages to always be encrypted and prevents the accidental
leakage of plaintext.

It is important to note that ghost messages and proof specifications, by
themselves, are \emph{not} sufficient to guaranteeing semantic security.
An adversary can simply use a different programming language and circumvent the
proof obligations imposed by \TLLC{}. However, these obligations are useful in
ensuring that honest parties correctly follow \emph{trusted} protocols to defend
against attackers. For example, in the Shannon cipher protocol above, an honest
party is required by the type system to send a ciphertext that is indeed encrypted
from the (trusted) algorithm $E$.

Another, more concrete, example of using ghost messages to specify secrets is the
Diffie-Hellman key exchange~\cite{DH76} protocol defined as follows:
\begin{align*}
  \textsf{DH}(p\ g: \textsf{int})
  :=\ & !\{a: \textsf{int}\}.\ !(A: \textsf{int}).\ !\{A = \textsf{powm}(g, a, p)\}.\\
      & ?\{b: \textsf{int}\}.\ ?(B: \textsf{int}).\ ?\{B = \textsf{powm}(g, b, p)\}.\ \End
\end{align*}
The \textsf{DH} protocol is parameterized by publicly known integers $p$ and $g$.
Without loss of generality, we refer to the message sender for the first row of the
protocol as Alice and the message sender for the second row as Bob. From Alice's
perspective, she first sends her secret value $a$ as a dependent ghost message to
initialize her half of the protocol. Next, her public value $A$ is sent as a real
message to Bob along with a proof that $A$ is correctly computed from values $p, g$ and $a$
(using modular exponentiation \textsf{powm}). At this point, Alice has finished sending
messages and waits for message from Bob to complete the key exchange. She first
``receives'' Bob's secret $b$ as a ghost message which initializes Bob's half of the
protocol. Later, Bob' public value $B$ is received as a real message along with a proof
that $B$ is correctly computed from $p, g$ and $b$. Notice that between Alice and Bob,
the only the real messages $A$ and $B$ will be exchanged at runtime. The secret values
$a$ and $b$ and the correctness proofs are all ghost message that are erased prior to
runtime. Basically, the \textsf{DH} protocol forces communication between Alice and Bob
to be encrypted and maintain secrecy at runtime.

\vspace{-0.4em}
\begin{center}
\begin{minipage}{0.45\textwidth}
\begingroup
\small
\addtolength{\jot}{-0.25em}
\begin{alignat*}{4}
  &\Def\ \textsf{Alice}\ (a\ p\ g: \textsf{int})\ (c : \CH{\textsf{DH}(p,g)}) \\
  &: \CM{\textsf{unit}} := \\
  &\quad\Let\ c \Leftarrow \Send\ c\ \{ a \}\ \In \\
  &\quad\Let\ c \Leftarrow \Send\ c\ (\textsf{powm}(g, a, p))\ \In \\
  &\quad\Let\ c \Leftarrow \Send\ c\ \{\textsf{refl}\}\ \In \\
  &\quad\Let\ \langle{\{b\}, c}\rangle \Leftarrow \Recv\ c\ \In \\
  &\quad\Let\ \langle{B, c}\rangle \Leftarrow \Recv\ c\ \In \\
  &\quad\Let\ \langle{\{\textit{pf}\}, c}\rangle \Leftarrow \Recv\ c\ \In \\
  &\quad\Close(c)
\end{alignat*}
\endgroup
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begingroup
\small
\addtolength{\jot}{-0.25em}
\begin{alignat*}{4}
  &\Def\ \textsf{Bob}\ (b\ p\ g: \textsf{int})\ (c : \HC{\textsf{DH}(p,g)}) \\
  &: \CM{\textsf{unit}} := \\
  &\quad\Let\ \langle{\{a\}, c}\rangle \Leftarrow \Recv\ c\ \In \\
  &\quad\Let\ \langle{A, c}\rangle \Leftarrow \Recv\ c\ \In \\
  &\quad\Let\ \langle{\{\textit{pf}\}, c}\rangle \Leftarrow \Recv\ c\ \In \\
  &\quad\Let\ c \Leftarrow \Send\ c\ \{ b \}\ \In \\
  &\quad\Let\ c \Leftarrow \Send\ c\ (\textsf{powm}(g, b, p))\ \In \\
  &\quad\Let\ c \Leftarrow \Send\ c\ \{\textsf{refl}\}\ \In \\
  &\quad\Wait(c)
\end{alignat*}
\endgroup
\end{minipage}
\end{center}
\vspace{0.5em}

The \textsf{DH} key exchange protocol can be implemented through two simple monadic
programs \textsf{Alice} and \textsf{Bob} as shown above. The $\mcC$ type constructor
here is the concurrency monad for integrating the \emph{effect} of concurrent
communication with the \emph{pure} functional core of \TLLC{}. There are two kinds of
\textsf{send} (and respectively \textsf{recv}) operations at play here.
The first kind, indicated by $\textsf{send}\ c\ \{v\}$ is for sending a ghost message
$v$ on channel $c$. After type checking, these ghost sends are compiled to no-ops
to that they do not participate in runtime communication. The second kind, indicated by
$\textsf{send}\ c\ (v)$, is for sending a real message $v$ on channel $c$. These
real sends are compiled to actual messages in the generated code. Finally, the
\textsf{close} and \textsf{wait} operations synchronize the termination of the protocol.
Notice that the duality of channel types $\CH{\textsf{DH}(p,g)}$ and $\HC{\textsf{DH}(p,g)}$
ensure that every send in \textsf{Alice} is matched by a corresponding receive in
\textsf{Bob} and vice versa. Moreover, \textsf{Alice} and \textsf{Bob} are enforced by the
type checker to correctly carry out the Diffie-Hellman key exchange.

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End:
